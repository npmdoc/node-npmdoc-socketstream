<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="http://www.socketstream.org"

    >socketstream (v0.5.3)</a>
</h1>
<h4>A framework for Realtime Web Apps</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.socketstream">module socketstream</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.api.require">
            function <span class="apidocSignatureSpan">socketstream.</span>api.require
            <span class="apidocSignatureSpan">(id, contextPath, defaultId)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.live_reload">
            function <span class="apidocSignatureSpan">socketstream.</span>live_reload
            <span class="apidocSignatureSpan">(ss, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.session.Cookie">
            function <span class="apidocSignatureSpan">socketstream.</span>session.Cookie
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.session.MemoryStore">
            function <span class="apidocSignatureSpan">socketstream.</span>session.MemoryStore
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.session.Session">
            function <span class="apidocSignatureSpan">socketstream.</span>session.Session
            <span class="apidocSignatureSpan">(req, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.session.Store">
            function <span class="apidocSignatureSpan">socketstream.</span>session.Store
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.set">
            function <span class="apidocSignatureSpan">socketstream.</span>set
            <span class="apidocSignatureSpan">(where, what)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.start">
            function <span class="apidocSignatureSpan">socketstream.</span>start
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.task">
            function <span class="apidocSignatureSpan">socketstream.</span>task
            <span class="apidocSignatureSpan">(name, dependents, fn)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">socketstream.</span>api</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">socketstream.</span>api.bundler</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">socketstream.</span>api.client</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">socketstream.</span>api.log</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">socketstream.</span>client</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">socketstream.</span>client.assets</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">socketstream.</span>client.formatters</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">socketstream.</span>client.templateEngine</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">socketstream.</span>events</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">socketstream.</span>file</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">socketstream.</span>generate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">socketstream.</span>http</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">socketstream.</span>http.cached</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">socketstream.</span>http.session</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">socketstream.</span>livereload</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">socketstream.</span>misc</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">socketstream.</span>publish</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">socketstream.</span>publish.transport</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">socketstream.</span>responders</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">socketstream.</span>session</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">socketstream.</span>session.Cookie.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">socketstream.</span>session.MemoryStore.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">socketstream.</span>session.Session.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">socketstream.</span>session.Store.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">socketstream.</span>session.store</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">socketstream.</span>tasks</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">socketstream.</span>tasks.orchestrator</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">socketstream.</span>unique_set</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">socketstream.</span>ws</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">socketstream.</span>ws.transport</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">socketstream.</span>env</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">socketstream.</span>root</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">socketstream.</span>version</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.socketstream.api">module socketstream.api</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.api.add">
            function <span class="apidocSignatureSpan">socketstream.api.</span>add
            <span class="apidocSignatureSpan">(name, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.api.defaultTask">
            function <span class="apidocSignatureSpan">socketstream.api.</span>defaultTask
            <span class="apidocSignatureSpan">(name, dependents, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.api.load">
            function <span class="apidocSignatureSpan">socketstream.api.</span>load
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.api.require">
            function <span class="apidocSignatureSpan">socketstream.api.</span>require
            <span class="apidocSignatureSpan">(id, contextPath, defaultId)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.api.task">
            function <span class="apidocSignatureSpan">socketstream.api.</span>task
            <span class="apidocSignatureSpan">(name, dependents, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.api.unload">
            function <span class="apidocSignatureSpan">socketstream.api.</span>unload
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">socketstream.api.</span>bundler</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">socketstream.api.</span>client</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">socketstream.api.</span>events</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">socketstream.api.</span>http</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">socketstream.api.</span>livereload</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">socketstream.api.</span>log</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">socketstream.api.</span>server</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">socketstream.api.</span>session</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">socketstream.api.</span>env</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">socketstream.api.</span>root</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">socketstream.api.</span>version</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.socketstream.api.bundler">module socketstream.api.bundler</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.api.bundler.browserifyLoader">
            function <span class="apidocSignatureSpan">socketstream.api.bundler.</span>browserifyLoader
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.api.bundler.clientFilePath">
            function <span class="apidocSignatureSpan">socketstream.api.bundler.</span>clientFilePath
            <span class="apidocSignatureSpan">(rel)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.api.bundler.constants">
            function <span class="apidocSignatureSpan">socketstream.api.bundler.</span>constants
            <span class="apidocSignatureSpan">(client)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.api.bundler.create">
            function <span class="apidocSignatureSpan">socketstream.api.bundler.</span>create
            <span class="apidocSignatureSpan">(bundler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.api.bundler.define">
            function <span class="apidocSignatureSpan">socketstream.api.bundler.</span>define
            <span class="apidocSignatureSpan">(client, args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.api.bundler.destsFor">
            function <span class="apidocSignatureSpan">socketstream.api.bundler.</span>destsFor
            <span class="apidocSignatureSpan">(client)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.api.bundler.entries">
            function <span class="apidocSignatureSpan">socketstream.api.bundler.</span>entries
            <span class="apidocSignatureSpan">(client, assetType)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.api.bundler.entryFor">
            function <span class="apidocSignatureSpan">socketstream.api.bundler.</span>entryFor
            <span class="apidocSignatureSpan">(bundle, file, part2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.api.bundler.findEntryPoint">
            function <span class="apidocSignatureSpan">socketstream.api.bundler.</span>findEntryPoint
            <span class="apidocSignatureSpan">(client)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.api.bundler.forEach">
            function <span class="apidocSignatureSpan">socketstream.api.bundler.</span>forEach
            <span class="apidocSignatureSpan">(fn, that)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.api.bundler.forget">
            function <span class="apidocSignatureSpan">socketstream.api.bundler.</span>forget
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.api.bundler.formatKb">
            function <span class="apidocSignatureSpan">socketstream.api.bundler.</span>formatKb
            <span class="apidocSignatureSpan">(size)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.api.bundler.get">
            function <span class="apidocSignatureSpan">socketstream.api.bundler.</span>get
            <span class="apidocSignatureSpan">(client)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.api.bundler.injectTailIfNeeded">
            function <span class="apidocSignatureSpan">socketstream.api.bundler.</span>injectTailIfNeeded
            <span class="apidocSignatureSpan">(output, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.api.bundler.load">
            function <span class="apidocSignatureSpan">socketstream.api.bundler.</span>load
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.api.bundler.loadFile">
            function <span class="apidocSignatureSpan">socketstream.api.bundler.</span>loadFile
            <span class="apidocSignatureSpan">(entry, opts, formatter, cb, errCb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.api.bundler.minifyCSS">
            function <span class="apidocSignatureSpan">socketstream.api.bundler.</span>minifyCSS
            <span class="apidocSignatureSpan">(files)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.api.bundler.minifyJS">
            function <span class="apidocSignatureSpan">socketstream.api.bundler.</span>minifyJS
            <span class="apidocSignatureSpan">(files)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.api.bundler.minifyJSFile">
            function <span class="apidocSignatureSpan">socketstream.api.bundler.</span>minifyJSFile
            <span class="apidocSignatureSpan">(originalCode, fileName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.api.bundler.packAssetSet">
            function <span class="apidocSignatureSpan">socketstream.api.bundler.</span>packAssetSet
            <span class="apidocSignatureSpan">(assetType, client, postProcess, done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.api.bundler.sourcePaths">
            function <span class="apidocSignatureSpan">socketstream.api.bundler.</span>sourcePaths
            <span class="apidocSignatureSpan">(paths)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.api.bundler.startCode">
            function <span class="apidocSignatureSpan">socketstream.api.bundler.</span>startCode
            <span class="apidocSignatureSpan">(client)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.api.bundler.systemLibs">
            function <span class="apidocSignatureSpan">socketstream.api.bundler.</span>systemLibs
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.api.bundler.systemModule">
            function <span class="apidocSignatureSpan">socketstream.api.bundler.</span>systemModule
            <span class="apidocSignatureSpan">(name, wrap)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.api.bundler.systemModules">
            function <span class="apidocSignatureSpan">socketstream.api.bundler.</span>systemModules
            <span class="apidocSignatureSpan">(wrap)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.api.bundler.unload">
            function <span class="apidocSignatureSpan">socketstream.api.bundler.</span>unload
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.api.bundler.updateCachedOndemandAssets">
            function <span class="apidocSignatureSpan">socketstream.api.bundler.</span>updateCachedOndemandAssets
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.api.bundler.wrapModule">
            function <span class="apidocSignatureSpan">socketstream.api.bundler.</span>wrapModule
            <span class="apidocSignatureSpan">(modPath, code)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.socketstream.api.client">module socketstream.api.client</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.api.client.send">
            function <span class="apidocSignatureSpan">socketstream.api.client.</span>send
            <span class="apidocSignatureSpan">(type, name, content, options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">socketstream.api.client.</span>dirs</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.socketstream.api.log">module socketstream.api.log</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.api.log.clientIssue">
            function <span class="apidocSignatureSpan">socketstream.api.log.</span>clientIssue
            <span class="apidocSignatureSpan">(client, options, err, more)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.api.log.debug">
            function <span class="apidocSignatureSpan">socketstream.api.log.</span>debug
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.api.log.error">
            function <span class="apidocSignatureSpan">socketstream.api.log.</span>error
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.api.log.info">
            function <span class="apidocSignatureSpan">socketstream.api.log.</span>info
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.api.log.trace">
            function <span class="apidocSignatureSpan">socketstream.api.log.</span>trace
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.api.log.warn">
            function <span class="apidocSignatureSpan">socketstream.api.log.</span>warn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.socketstream.api.require">module socketstream.api.require</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.api.require.require">
            function <span class="apidocSignatureSpan">socketstream.api.</span>require
            <span class="apidocSignatureSpan">(id, contextPath, defaultId)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.api.require.forEach">
            function <span class="apidocSignatureSpan">socketstream.api.require.</span>forEach
            <span class="apidocSignatureSpan">(pattern, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.api.require.resolve">
            function <span class="apidocSignatureSpan">socketstream.api.require.</span>resolve
            <span class="apidocSignatureSpan">(id)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.socketstream.client">module socketstream.client</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.client.define">
            function <span class="apidocSignatureSpan">socketstream.client.</span>define
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.client.forget">
            function <span class="apidocSignatureSpan">socketstream.client.</span>forget
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.client.init">
            function <span class="apidocSignatureSpan">socketstream.client.</span>init
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.client.load">
            function <span class="apidocSignatureSpan">socketstream.client.</span>load
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.client.packAssets">
            function <span class="apidocSignatureSpan">socketstream.client.</span>packAssets
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.client.reloadCached">
            function <span class="apidocSignatureSpan">socketstream.client.</span>reloadCached
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.client.reloadClients">
            function <span class="apidocSignatureSpan">socketstream.client.</span>reloadClients
            <span class="apidocSignatureSpan">(changedPath, event)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.client.servePacked">
            function <span class="apidocSignatureSpan">socketstream.client.</span>servePacked
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.client.set">
            function <span class="apidocSignatureSpan">socketstream.client.</span>set
            <span class="apidocSignatureSpan">(newOption)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.client.task">
            function <span class="apidocSignatureSpan">socketstream.client.</span>task
            <span class="apidocSignatureSpan">(client, name, dependents, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.client.unload">
            function <span class="apidocSignatureSpan">socketstream.client.</span>unload
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">socketstream.client.</span>assets</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">socketstream.client.</span>dirs</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">socketstream.client.</span>formatters</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">socketstream.client.</span>livereload</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">socketstream.client.</span>options</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">socketstream.client.</span>plugins</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">socketstream.client.</span>templateEngine</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">socketstream.client.</span>faviconPath</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.socketstream.client.assets">module socketstream.client.assets</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.client.assets.load">
            function <span class="apidocSignatureSpan">socketstream.client.assets.</span>load
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.client.assets.send">
            function <span class="apidocSignatureSpan">socketstream.client.assets.</span>send
            <span class="apidocSignatureSpan">(type, name, content, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.client.assets.unload">
            function <span class="apidocSignatureSpan">socketstream.client.assets.</span>unload
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">socketstream.client.</span>assets</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.socketstream.client.formatters">module socketstream.client.formatters</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.client.formatters.add">
            function <span class="apidocSignatureSpan">socketstream.client.formatters.</span>add
            <span class="apidocSignatureSpan">(nameOrModule, config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.client.formatters.forget">
            function <span class="apidocSignatureSpan">socketstream.client.formatters.</span>forget
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.client.formatters.load">
            function <span class="apidocSignatureSpan">socketstream.client.formatters.</span>load
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.socketstream.client.templateEngine">module socketstream.client.templateEngine</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.client.templateEngine.forget">
            function <span class="apidocSignatureSpan">socketstream.client.templateEngine.</span>forget
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.client.templateEngine.generate">
            function <span class="apidocSignatureSpan">socketstream.client.templateEngine.</span>generate
            <span class="apidocSignatureSpan">(bundler, files, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.client.templateEngine.load">
            function <span class="apidocSignatureSpan">socketstream.client.templateEngine.</span>load
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.client.templateEngine.use">
            function <span class="apidocSignatureSpan">socketstream.client.templateEngine.</span>use
            <span class="apidocSignatureSpan">(nameOrModule, dirs, config)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.socketstream.file">module socketstream.file</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.file.findExtForBasePath">
            function <span class="apidocSignatureSpan">socketstream.file.</span>findExtForBasePath
            <span class="apidocSignatureSpan">(basepath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.file.isDir">
            function <span class="apidocSignatureSpan">socketstream.file.</span>isDir
            <span class="apidocSignatureSpan">(filePath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.file.loadPackageJSON">
            function <span class="apidocSignatureSpan">socketstream.file.</span>loadPackageJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.file.readDirSync">
            function <span class="apidocSignatureSpan">socketstream.file.</span>readDirSync
            <span class="apidocSignatureSpan">(start)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.socketstream.generate">module socketstream.generate</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.generate.generate">
            function <span class="apidocSignatureSpan">socketstream.</span>generate
            <span class="apidocSignatureSpan">(program)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.socketstream.http">module socketstream.http</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.http.load">
            function <span class="apidocSignatureSpan">socketstream.http.</span>load
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.http.route">
            function <span class="apidocSignatureSpan">socketstream.http.</span>route
            <span class="apidocSignatureSpan">(url, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.http.set">
            function <span class="apidocSignatureSpan">socketstream.http.</span>set
            <span class="apidocSignatureSpan">(newSettings)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.http.unload">
            function <span class="apidocSignatureSpan">socketstream.http.</span>unload
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">socketstream.http.</span>cached</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">socketstream.http.</span>session</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">socketstream.http.</span>settings</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.socketstream.http.cached">module socketstream.http.cached</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.http.cached.loadAssets">
            function <span class="apidocSignatureSpan">socketstream.http.cached.</span>loadAssets
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.http.cached.loadStatic">
            function <span class="apidocSignatureSpan">socketstream.http.cached.</span>loadStatic
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.http.cached.middleware">
            function <span class="apidocSignatureSpan">socketstream.http.cached.</span>middleware
            <span class="apidocSignatureSpan">(req, res, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.http.cached.route">
            function <span class="apidocSignatureSpan">socketstream.http.cached.</span>route
            <span class="apidocSignatureSpan">(url, fn, filePath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.http.cached.send">
            function <span class="apidocSignatureSpan">socketstream.http.cached.</span>send
            <span class="apidocSignatureSpan">(url, res)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.http.cached.set">
            function <span class="apidocSignatureSpan">socketstream.http.cached.</span>set
            <span class="apidocSignatureSpan">(url, content, mimeType)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.socketstream.http.session">module socketstream.http.session</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.http.session.middleware">
            function <span class="apidocSignatureSpan">socketstream.http.session.</span>middleware
            <span class="apidocSignatureSpan">(req, res, next)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.socketstream.live_reload">module socketstream.live_reload</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.live_reload.live_reload">
            function <span class="apidocSignatureSpan">socketstream.</span>live_reload
            <span class="apidocSignatureSpan">(ss, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.live_reload.unload">
            function <span class="apidocSignatureSpan">socketstream.live_reload.</span>unload
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.socketstream.livereload">module socketstream.livereload</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.livereload.added">
            function <span class="apidocSignatureSpan">socketstream.livereload.</span>added
            <span class="apidocSignatureSpan">(changedPath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.livereload.changed">
            function <span class="apidocSignatureSpan">socketstream.livereload.</span>changed
            <span class="apidocSignatureSpan">(changedPath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.livereload.removed">
            function <span class="apidocSignatureSpan">socketstream.livereload.</span>removed
            <span class="apidocSignatureSpan">(changedPath)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.socketstream.misc">module socketstream.misc</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.misc.defaults">
            function <span class="apidocSignatureSpan">socketstream.misc.</span>defaults
            <span class="apidocSignatureSpan">(args, defaults)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.misc.extend">
            function <span class="apidocSignatureSpan">socketstream.misc.</span>extend
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.misc.parseWsMessage">
            function <span class="apidocSignatureSpan">socketstream.misc.</span>parseWsMessage
            <span class="apidocSignatureSpan">(msg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.misc.randomString">
            function <span class="apidocSignatureSpan">socketstream.misc.</span>randomString
            <span class="apidocSignatureSpan">(len)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.socketstream.publish">module socketstream.publish</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.publish.api">
            function <span class="apidocSignatureSpan">socketstream.publish.</span>api
            <span class="apidocSignatureSpan">(transport)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">socketstream.publish.</span>transport</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.socketstream.publish.transport">module socketstream.publish.transport</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.publish.transport.load">
            function <span class="apidocSignatureSpan">socketstream.publish.transport.</span>load
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.publish.transport.use">
            function <span class="apidocSignatureSpan">socketstream.publish.transport.</span>use
            <span class="apidocSignatureSpan">(nameOrModule, cfg)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.socketstream.responders">module socketstream.responders</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.responders.add">
            function <span class="apidocSignatureSpan">socketstream.responders.</span>add
            <span class="apidocSignatureSpan">(nameOrModule, config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.responders.clear">
            function <span class="apidocSignatureSpan">socketstream.responders.</span>clear
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.responders.load">
            function <span class="apidocSignatureSpan">socketstream.responders.</span>load
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.socketstream.session">module socketstream.session</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.session.Cookie">
            function <span class="apidocSignatureSpan">socketstream.session.</span>Cookie
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.session.MemoryStore">
            function <span class="apidocSignatureSpan">socketstream.session.</span>MemoryStore
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.session.Session">
            function <span class="apidocSignatureSpan">socketstream.session.</span>Session
            <span class="apidocSignatureSpan">(req, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.session.Store">
            function <span class="apidocSignatureSpan">socketstream.session.</span>Store
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.session.create">
            function <span class="apidocSignatureSpan">socketstream.session.</span>create
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.session.extractSocketSessionToken">
            function <span class="apidocSignatureSpan">socketstream.session.</span>extractSocketSessionToken
            <span class="apidocSignatureSpan">(request)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.session.find">
            function <span class="apidocSignatureSpan">socketstream.session.</span>find
            <span class="apidocSignatureSpan">(sessionId, socketId, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.session.setStrategy">
            function <span class="apidocSignatureSpan">socketstream.session.</span>setStrategy
            <span class="apidocSignatureSpan">(_strategy)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">socketstream.session.</span>options</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">socketstream.session.</span>store</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">socketstream.session.</span>strategy</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.socketstream.session.Cookie">module socketstream.session.Cookie</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.session.Cookie.Cookie">
            function <span class="apidocSignatureSpan">socketstream.session.</span>Cookie
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.socketstream.session.Cookie.prototype">module socketstream.session.Cookie.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.session.Cookie.prototype.serialize">
            function <span class="apidocSignatureSpan">socketstream.session.Cookie.prototype.</span>serialize
            <span class="apidocSignatureSpan">(name, val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.session.Cookie.prototype.toJSON">
            function <span class="apidocSignatureSpan">socketstream.session.Cookie.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">socketstream.session.Cookie.prototype.</span>data</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.socketstream.session.MemoryStore">module socketstream.session.MemoryStore</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.session.MemoryStore.MemoryStore">
            function <span class="apidocSignatureSpan">socketstream.session.</span>MemoryStore
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.socketstream.session.MemoryStore.prototype">module socketstream.session.MemoryStore.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.session.MemoryStore.prototype.all">
            function <span class="apidocSignatureSpan">socketstream.session.MemoryStore.prototype.</span>all
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.session.MemoryStore.prototype.clear">
            function <span class="apidocSignatureSpan">socketstream.session.MemoryStore.prototype.</span>clear
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.session.MemoryStore.prototype.destroy">
            function <span class="apidocSignatureSpan">socketstream.session.MemoryStore.prototype.</span>destroy
            <span class="apidocSignatureSpan">(sessionId, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.session.MemoryStore.prototype.get">
            function <span class="apidocSignatureSpan">socketstream.session.MemoryStore.prototype.</span>get
            <span class="apidocSignatureSpan">(sessionId, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.session.MemoryStore.prototype.length">
            function <span class="apidocSignatureSpan">socketstream.session.MemoryStore.prototype.</span>length
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.session.MemoryStore.prototype.set">
            function <span class="apidocSignatureSpan">socketstream.session.MemoryStore.prototype.</span>set
            <span class="apidocSignatureSpan">(sessionId, session, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.session.MemoryStore.prototype.touch">
            function <span class="apidocSignatureSpan">socketstream.session.MemoryStore.prototype.</span>touch
            <span class="apidocSignatureSpan">(sessionId, session, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.socketstream.session.Session">module socketstream.session.Session</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.session.Session.Session">
            function <span class="apidocSignatureSpan">socketstream.session.</span>Session
            <span class="apidocSignatureSpan">(req, data)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.socketstream.session.Session.prototype">module socketstream.session.Session.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.session.Session.prototype.destroy">
            function <span class="apidocSignatureSpan">socketstream.session.Session.prototype.</span>destroy
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.session.Session.prototype.regenerate">
            function <span class="apidocSignatureSpan">socketstream.session.Session.prototype.</span>regenerate
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.session.Session.prototype.reload">
            function <span class="apidocSignatureSpan">socketstream.session.Session.prototype.</span>reload
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.session.Session.prototype.resetMaxAge">
            function <span class="apidocSignatureSpan">socketstream.session.Session.prototype.</span>resetMaxAge
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.session.Session.prototype.save">
            function <span class="apidocSignatureSpan">socketstream.session.Session.prototype.</span>save
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.session.Session.prototype.touch">
            function <span class="apidocSignatureSpan">socketstream.session.Session.prototype.</span>touch
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.socketstream.session.Store">module socketstream.session.Store</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.session.Store.Store">
            function <span class="apidocSignatureSpan">socketstream.session.</span>Store
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.socketstream.session.Store.prototype">module socketstream.session.Store.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.session.Store.prototype.createSession">
            function <span class="apidocSignatureSpan">socketstream.session.Store.prototype.</span>createSession
            <span class="apidocSignatureSpan">(req, sess)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.session.Store.prototype.load">
            function <span class="apidocSignatureSpan">socketstream.session.Store.prototype.</span>load
            <span class="apidocSignatureSpan">(sid, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.session.Store.prototype.regenerate">
            function <span class="apidocSignatureSpan">socketstream.session.Store.prototype.</span>regenerate
            <span class="apidocSignatureSpan">(req, fn)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.socketstream.session.store">module socketstream.session.store</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.session.store.get">
            function <span class="apidocSignatureSpan">socketstream.session.store.</span>get
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.session.store.use">
            function <span class="apidocSignatureSpan">socketstream.session.store.</span>use
            <span class="apidocSignatureSpan">(nameOrStore, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.socketstream.tasks">module socketstream.tasks</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.tasks._packTasks">
            function <span class="apidocSignatureSpan">socketstream.tasks.</span>_packTasks
            <span class="apidocSignatureSpan">(all)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.tasks.add">
            function <span class="apidocSignatureSpan">socketstream.tasks.</span>add
            <span class="apidocSignatureSpan">(name, dependents, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.tasks.defaultTask">
            function <span class="apidocSignatureSpan">socketstream.tasks.</span>defaultTask
            <span class="apidocSignatureSpan">(name, dependents, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.tasks.defaults">
            function <span class="apidocSignatureSpan">socketstream.tasks.</span>defaults
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.tasks.forget">
            function <span class="apidocSignatureSpan">socketstream.tasks.</span>forget
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.tasks.on">
            function <span class="apidocSignatureSpan">socketstream.tasks.</span>on
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.tasks.plan">
            function <span class="apidocSignatureSpan">socketstream.tasks.</span>plan
            <span class="apidocSignatureSpan">(args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.tasks.start">
            function <span class="apidocSignatureSpan">socketstream.tasks.</span>start
            <span class="apidocSignatureSpan">(tasks, done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.tasks.unload">
            function <span class="apidocSignatureSpan">socketstream.tasks.</span>unload
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.tasks.use">
            function <span class="apidocSignatureSpan">socketstream.tasks.</span>use
            <span class="apidocSignatureSpan">(gulp)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">socketstream.tasks.</span>orchestrator</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.socketstream.tasks.orchestrator">module socketstream.tasks.orchestrator</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.tasks.orchestrator.set">
            function <span class="apidocSignatureSpan">socketstream.tasks.orchestrator.</span>set
            <span class="apidocSignatureSpan">(where, what)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.tasks.orchestrator.start">
            function <span class="apidocSignatureSpan">socketstream.tasks.orchestrator.</span>start
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.tasks.orchestrator.task">
            function <span class="apidocSignatureSpan">socketstream.tasks.orchestrator.</span>task
            <span class="apidocSignatureSpan">(name, dependents, fn)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">socketstream.tasks.orchestrator.</span>api</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">socketstream.tasks.orchestrator.</span>client</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">socketstream.tasks.orchestrator.</span>events</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">socketstream.tasks.orchestrator.</span>http</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">socketstream.tasks.orchestrator.</span>livereload</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">socketstream.tasks.orchestrator.</span>publish</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">socketstream.tasks.orchestrator.</span>responders</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">socketstream.tasks.orchestrator.</span>session</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">socketstream.tasks.orchestrator.</span>tasks</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">socketstream.tasks.orchestrator.</span>ws</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">socketstream.tasks.orchestrator.</span>env</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">socketstream.tasks.orchestrator.</span>root</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">socketstream.tasks.orchestrator.</span>version</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.socketstream.unique_set">module socketstream.unique_set</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.unique_set.UniqueSet">
            function <span class="apidocSignatureSpan">socketstream.unique_set.</span>UniqueSet
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.socketstream.ws">module socketstream.ws</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.ws.listen">
            function <span class="apidocSignatureSpan">socketstream.ws.</span>listen
            <span class="apidocSignatureSpan">(port, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.ws.load">
            function <span class="apidocSignatureSpan">socketstream.ws.</span>load
            <span class="apidocSignatureSpan">(responders, eventTransport)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.ws.unload">
            function <span class="apidocSignatureSpan">socketstream.ws.</span>unload
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">socketstream.ws.</span>transport</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.socketstream.ws.transport">module socketstream.ws.transport</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.ws.transport.load">
            function <span class="apidocSignatureSpan">socketstream.ws.transport.</span>load
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.socketstream.ws.transport.use">
            function <span class="apidocSignatureSpan">socketstream.ws.transport.</span>use
            <span class="apidocSignatureSpan">(nameOrModule, cfg)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">socketstream.ws.transport.</span>http</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">socketstream.ws.transport.</span>ws</span>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.socketstream" id="apidoc.module.socketstream">module socketstream</a></h1>


    <h2>
        <a href="#apidoc.element.socketstream.api.require" id="apidoc.element.socketstream.api.require">
        function <span class="apidocSignatureSpan">socketstream.</span>api.require
        <span class="apidocSignatureSpan">(id, contextPath, defaultId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function requires(id, contextPath, defaultId) {
		var context, callback;
		if (typeof defaultId === &#x27;function&#x27;) {
			callback = defaultId;
			defaultId = null;
		}
		if (contextPath) {
			context = contexts[contextPath];
			if (context === undefined) {
				context = contexts[contextPath] = {
					rel : context,
					prefix: path.join(__dirname, &#x27;..&#x27;, contextPath),
					inContext: function(id) {
						try {
							var p = path.join(context.prefix,id);
							if (require.resolve(p)) { // gives full path
								return require(p);
							}
						} catch(ex) {}
					}
				};
			}
    }

    switch(typeof id) {
      case &#x27;object&#x27;:
      case &#x27;function&#x27;:
        if (id) {
          return id; // straight object/function will just resolve straight away
        }
        break;
      case &#x27;string&#x27;:
        if (context) {
          // builtin modules take first priority
          var inContext = context.inContext(id);
          if (inContext) { return inContext; }

        }

        // if relative base on main script location
        if (id.charAt(0) === &#x27;.&#x27;) {
          var inProject = path.join(ss.root,id);
          if (fs.existsSync(inProject+&#x27;.js&#x27;)) {
            debug(&#x27;found &#x27;+id);
            return require(inProject);
          }
        }

        // getting a packaged module
        var mod = projectOrHereRequire(id,ss.root);
        if (mod) {
          debug(&#x27;found &#x27;+id+&#x27; in project or SocketStream&#x27;);
          return require(mod);
        }
        break;
    }

		if (context &#x26;&#x26; defaultId) {
			// default looked up in context first
			var defaultInContext = context.inContext(defaultId);
			if (defaultInContext) { return defaultInContext; }

			// all bets are off
			mod = projectOrHereRequire(defaultId,ss.root);
			if (mod) {
				debug(&#x27;found &#x27;+defaultId+&#x27; in project or SocketStream&#x27;);
				return require(mod);
			}
		}

		if (callback) {
			return callback({
				id:id
			});
		}
		throw new Error(&#x27;Cannot find module &#x22;&#x27; + id + &#x27;&#x22; in socketstream or project&#x27;);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...



// Entry point for app.js
&#x27;use strict&#x27;;

var ss = require(&#x27;./lib/socketstream.js&#x27;),
  express = ss.<span class="apidocCodeKeywordSpan">api.require</span>(&#x27;express&#x27;);

module.exports = function() {
var app = ss.http.middleware = express();

app.listen = function() {
  ss.ws.listen.apply(ss.ws, arguments);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.live_reload" id="apidoc.element.socketstream.live_reload">
        function <span class="apidocSignatureSpan">socketstream.</span>live_reload
        <span class="apidocSignatureSpan">(ss, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">live_reload = function (ss, options) {

  var pathlib = require(&#x27;path&#x27;),
      chokidar = ss.require(&#x27;chokidar&#x27;);

  var watchDirs = (function() {
    var _i, _len, _ref, _results;
    _ref = options.liveReload;
    _results = [];
    for (_i = 0, _len = _ref.length; _i &#x3c; _len; _i++) {
      var dir = _ref[_i];
      _results.push(pathlib.join(ss.root, options.dirs[dir] || dir));
    }
    return _results;
  })();

  watcher = chokidar.watch(watchDirs, {
    ignoreInitial: true,
    ignored: /(\/\.|~$)/
  });
  watcher.on(&#x27;add&#x27;, function(path) {
    debug(&#x27;added: %s&#x27;,path);
    return ss.livereload.added(path);
  });
  watcher.on(&#x27;change&#x27;, function(path) {
    debug(&#x27;added: %s&#x27;,path);
    return ss.livereload.changed(path);
  });
  watcher.on(&#x27;unlink&#x27;, function(path) {
    debug(&#x27;added: %s&#x27;,path);
    return ss.livereload.removed(path);
  });
  watcher.on(&#x27;error&#x27;, function(error) {
    return ss.log.error(&#x27;&#x27;.red, (&#x27;Error: &#x27; + error).red);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.session.Cookie" id="apidoc.element.socketstream.session.Cookie">
        function <span class="apidocSignatureSpan">socketstream.</span>session.Cookie
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Cookie(options) {
  this.path = &#x27;/&#x27;;
  this.maxAge = null;
  this.httpOnly = true;
  if (options) {merge(this, options);}
  this.originalMaxAge = undefined === this.originalMaxAge ?
      this.maxAge :
      this.originalMaxAge;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.session.MemoryStore" id="apidoc.element.socketstream.session.MemoryStore">
        function <span class="apidocSignatureSpan">socketstream.</span>session.MemoryStore
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MemoryStore() {
  Store.call(this)
  this.sessions = Object.create(null)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.session.Session" id="apidoc.element.socketstream.session.Session">
        function <span class="apidocSignatureSpan">socketstream.</span>session.Session
        <span class="apidocSignatureSpan">(req, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Session(req, data) {
  Object.defineProperty(this, &#x27;req&#x27;, { value: req });
  Object.defineProperty(this, &#x27;id&#x27;, { value: req.sessionID });

  if (typeof data === &#x27;object&#x27; &#x26;&#x26; data !== null) {
    // merge data into this, ignoring prototype properties
    for (var prop in data) {
      if (!(prop in this)) {
        this[prop] = data[prop]
      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.session.Store" id="apidoc.element.socketstream.session.Store">
        function <span class="apidocSignatureSpan">socketstream.</span>session.Store
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Store(){}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.set" id="apidoc.element.socketstream.set">
        function <span class="apidocSignatureSpan">socketstream.</span>set
        <span class="apidocSignatureSpan">(where, what)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">set = function (where, what) {
  var path = require(&#x27;path&#x27;);

  if (where === &#x27;*&#x27;) {
    if (what.root) {
      if (path.isAbsolute(what.root)) {
        exports.root = api.root = what.root;
      } else {
        var scriptBase = path.dirname(process.argv[1]);
        exports.root = api.root = path.join(scriptBase,what.root);
      }
    }

    if (what.client) {
      client.set(what.client);
    }
    if (what.http) {
      http.set(what.http);
    }
    //TODO vars, locals remembered as fallbacks
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  app.socketstream = function( fn(req,stream) )

  app.stream = ss.http.stream;
  */
  app.stream = ss.http.stream;

  if (ss.env === &#x27;development&#x27;) {
app.<span class="apidocCodeKeywordSpan">set</span>(&#x27;views&#x27;, ss.client.dirs.views);
// Showing stack errors
app.set(&#x27;showStackError&#x27;, true);
// Disable views cache
app.set(&#x27;view cache&#x27;, false);

// Environment dependent middleware
// throws cannot find stack
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.start" id="apidoc.element.socketstream.start">
        function <span class="apidocSignatureSpan">socketstream.</span>start
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">start = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var ss = module.exports = require(&#x27;./lib/socketstream.js&#x27;),
    gulp = ss.api.require(&#x27;gulp&#x27;);

// gulp is used as the Orchestrator
ss.tasks.use(gulp);

// Your app.js should be required from the gulpfile.js
// .<span class="apidocCodeKeywordSpan">start</span>() will normally be called from app.js, and will not run tasks.
ss.start = function() {};

// default tasks are defined
ss.tasks.defaults();

// don&#x27;t load API yet as the app.js still needs to be loaded
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.task" id="apidoc.element.socketstream.task">
        function <span class="apidocSignatureSpan">socketstream.</span>task
        <span class="apidocSignatureSpan">(name, dependents, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function task(name, dependents, fn) {
  orchestrator.add(name, dependents, fn);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




































































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.socketstream.api" id="apidoc.module.socketstream.api">module socketstream.api</a></h1>


    <h2>
        <a href="#apidoc.element.socketstream.api.add" id="apidoc.element.socketstream.api.add">
        function <span class="apidocSignatureSpan">socketstream.api.</span>add
        <span class="apidocSignatureSpan">(name, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">add = function (name, fn) {
  if (api[name]) {
    throw new Error(&#x27;Unable to register internal API extension \&#x27;&#x27; + name + &#x27;\&#x27; as this name has already been taken&#x27;);
  } else {
    api[name] = fn;
    return true;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        &#x27;// Define a single-page client called \&#x27;main\&#x27;\nss.client.define(\&#x27;main\&#x27;, {\n  view: \&#x27;app
.&#x27; + viewExtension + &#x27;\&#x27;,\n  css:  [\&#x27;&#x27; + (clientFiles.css.join(&#x27;\&#x27;, \&#x27;&#x27;)) + &#x27;\&#x27;],\n  code: [\&#x27;&#x27; + (clientFiles.code.join(&#x27;\&#x27;, \&#x27;&#x27;)) + &#x27;\&#x27;],\n  tmpl: \&#x27;chat\&#x27;\n});\n\n// Serve this client on the root URL\nss.http.route(\&#x27;/\&#x27;, function(req, res){\n  res.serveClient(\&#x27;main\&#x27;);\n});\n&#x27;;

/* List any selected formatters */
if (selectedFormatters.length &#x3e; 0) {
  appjs += &#x27;\n// Code Formatters\n&#x27;;
}
selectedFormatters.forEach(function (name) {
  return appjs += &#x27;ss.client.formatters.<span class="apidocCodeKeywordSpan">add</span>(require(\&#x27;ss-&#x27; + name + &#
x27;\&#x27;));\n&#x27;;
});
appjs += &#x27;\n// Use server-side compiled Hogan (Mustache) templates. Others engines available\n&#x27;+
         &#x27;ss.client.templateEngine.use(require(\&#x27;ss-hogan\&#x27;));\n\n// Minimize and pack assets if you type: SS_ENV
=production node app.js\n&#x27;+
         &#x27;if (ss.env === \&#x27;production\&#x27;) ss.client.packAssets();\n&#x27;;
if (program.repl) {
  appjs += &#x27;\n// Start Console Server (REPL)\n// To install client: sudo npm install -g ss-console\n&#x27;+
           &#x27;// To connect: ss-console &#x3c;optional_host_or_port&#x3e;\nvar consoleServer = require(\&#x27;ss-console\&#x27
;)(ss);\nconsoleServer.listen(5000);\n&#x27;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.api.defaultTask" id="apidoc.element.socketstream.api.defaultTask">
        function <span class="apidocSignatureSpan">socketstream.api.</span>defaultTask
        <span class="apidocSignatureSpan">(name, dependents, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function defaultTask(name, dependents, fn) {
  if (!orchestrator.hasTask(name)) {
    orchestrator.add(name, dependents, fn);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
log = require(&#x27;../utils/log&#x27;),
view = require(&#x27;../client/view&#x27;),
liveReload = require(&#x27;./live_reload&#x27;);

module.exports = function(ss, options, orchestrator) {

  return function() {
ss.<span class="apidocCodeKeywordSpan">defaultTask</span>(&#x27;application&#x27;, function() {});

ss.defaultTask(&#x27;start-server&#x27;,[&#x27;application&#x27;],function(done) {
  socketstream.ws.listen(ss.http.settings.port || 3000, done);
});

ss.defaultTask(&#x27;load-api&#x27;, function() {
  ss.load();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.api.load" id="apidoc.element.socketstream.api.load">
        function <span class="apidocSignatureSpan">socketstream.api.</span>load
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function load() {
  if (!loaded) {
    var addons = [], skipped = [];

    // load addon modules
    api.require.forEach([&#x27;socketstream-*&#x27;,&#x27;socketstream.*&#x27;],function(mod,id) {
      if (typeof mod === &#x27;function&#x27;) {
        try {
          mod(api);
          addons.push(id);
        } catch(ex) {
          debug(&#x27;Failed to load &#x27;+id+&#x27;. &#x27;,ex);
        }
      } else {
        skipped.push(id);
      }
    });
    debug(&#x27;Addons: &#x27;+
      addons.length? addons.join(&#x27; + &#x27;) + &#x27; Loaded. &#x27;:&#x27; None. &#x27;+
      skipped.length? skipped.join(&#x27; + &#x27;) + &#x27; Skipped. &#x27;:&#x27;&#x27;);

    // load assets in cache
    http.load();

    // Load Client Asset Manager
    client.load();

    // Load internal and project responders
    api.server.responders = exports.responders.load();

    api.server.eventTransport = publish.transport.load();

    // Extend the internal API with a publish object you can call from your own server-side code
    api.publish = publish.api(api.server.eventTransport);

    // Bind responders to websocket
    ws.load(api.server.responders, api.server.eventTransport);

    debug(&#x27;API loaded.&#x27;);
  }
  loaded = true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    ss.defaultTask(&#x27;application&#x27;, function() {});

    ss.defaultTask(&#x27;start-server&#x27;,[&#x27;application&#x27;],function(done) {
socketstream.ws.listen(ss.http.settings.port || 3000, done);
    });

    ss.defaultTask(&#x27;load-api&#x27;, function() {
ss.<span class="apidocCodeKeywordSpan">load</span>();
    });

    ss.defaultTask(&#x27;test-socketstream&#x27;, [&#x27;load-api&#x27;], function() {
var sessionID = ss.session.create();

// jshint loopfunc:true
for (var id in ss.server.responders) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.api.require" id="apidoc.element.socketstream.api.require">
        function <span class="apidocSignatureSpan">socketstream.api.</span>require
        <span class="apidocSignatureSpan">(id, contextPath, defaultId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function requires(id, contextPath, defaultId) {
		var context, callback;
		if (typeof defaultId === &#x27;function&#x27;) {
			callback = defaultId;
			defaultId = null;
		}
		if (contextPath) {
			context = contexts[contextPath];
			if (context === undefined) {
				context = contexts[contextPath] = {
					rel : context,
					prefix: path.join(__dirname, &#x27;..&#x27;, contextPath),
					inContext: function(id) {
						try {
							var p = path.join(context.prefix,id);
							if (require.resolve(p)) { // gives full path
								return require(p);
							}
						} catch(ex) {}
					}
				};
			}
    }

    switch(typeof id) {
      case &#x27;object&#x27;:
      case &#x27;function&#x27;:
        if (id) {
          return id; // straight object/function will just resolve straight away
        }
        break;
      case &#x27;string&#x27;:
        if (context) {
          // builtin modules take first priority
          var inContext = context.inContext(id);
          if (inContext) { return inContext; }

        }

        // if relative base on main script location
        if (id.charAt(0) === &#x27;.&#x27;) {
          var inProject = path.join(ss.root,id);
          if (fs.existsSync(inProject+&#x27;.js&#x27;)) {
            debug(&#x27;found &#x27;+id);
            return require(inProject);
          }
        }

        // getting a packaged module
        var mod = projectOrHereRequire(id,ss.root);
        if (mod) {
          debug(&#x27;found &#x27;+id+&#x27; in project or SocketStream&#x27;);
          return require(mod);
        }
        break;
    }

		if (context &#x26;&#x26; defaultId) {
			// default looked up in context first
			var defaultInContext = context.inContext(defaultId);
			if (defaultInContext) { return defaultInContext; }

			// all bets are off
			mod = projectOrHereRequire(defaultId,ss.root);
			if (mod) {
				debug(&#x27;found &#x27;+defaultId+&#x27; in project or SocketStream&#x27;);
				return require(mod);
			}
		}

		if (callback) {
			return callback({
				id:id
			});
		}
		throw new Error(&#x27;Cannot find module &#x22;&#x27; + id + &#x27;&#x22; in socketstream or project&#x27;);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...



// Entry point for app.js
&#x27;use strict&#x27;;

var ss = require(&#x27;./lib/socketstream.js&#x27;),
  express = ss.api.<span class="apidocCodeKeywordSpan">require</span>(&#x27;express&#x27;);

module.exports = function() {
var app = ss.http.middleware = express();

app.listen = function() {
  ss.ws.listen.apply(ss.ws, arguments);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.api.task" id="apidoc.element.socketstream.api.task">
        function <span class="apidocSignatureSpan">socketstream.api.</span>task
        <span class="apidocSignatureSpan">(name, dependents, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function task(name, dependents, fn) {
  orchestrator.add(name, dependents, fn);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.api.unload" id="apidoc.element.socketstream.api.unload">
        function <span class="apidocSignatureSpan">socketstream.api.</span>unload
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function unload() {
  loaded = false;

  tasks.unload();
  client.unload();
  client.assets.unload();
  http.unload();
  api.server.responders = undefined;
  ws.unload();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
























</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.socketstream.api.bundler" id="apidoc.module.socketstream.api.bundler">module socketstream.api.bundler</a></h1>


    <h2>
        <a href="#apidoc.element.socketstream.api.bundler.browserifyLoader" id="apidoc.element.socketstream.api.bundler.browserifyLoader">
        function <span class="apidocSignatureSpan">socketstream.api.bundler.</span>browserifyLoader
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">browserifyLoader = function () {
  if (!this.browserifyContent) {
    this.browserifyContent = fs.readFileSync(path.join(__dirname,&#x27;browserify.client.js&#x27;),&#x27;utf8&#x27;);
  }
  return {
    type: &#x27;mod&#x27;,
    file: &#x27;loader&#x27;,
    includeType: &#x27;system&#x27;,
    names: [&#x27;browserify.client.js&#x27;],
    content: this.browserifyContent
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.api.bundler.clientFilePath" id="apidoc.element.socketstream.api.bundler.clientFilePath">
        function <span class="apidocSignatureSpan">socketstream.api.bundler.</span>clientFilePath
        <span class="apidocSignatureSpan">(rel)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clientFilePath = function (rel) {
  if (typeof rel === &#x27;object&#x27;) {
    // entry object
    rel = rel.file;
  }
  return path.join(ss.root,rel);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
constants: bundler.constants(),
locals: bundler.locals()
        };

        return bundler.format(desc,
opts, formatter, function(output) {

templates.push(wrapTemplate(output, desc.file, ss.bundler.<span class="apidocCodeKeywordSpan">clientFilePath</span>(desc), opts,
options, engine, prevEngine));
prevEngine = engine;

// Return if last template
if (templates.length === files.length) {
  output = templates.join(&#x27;&#x27;);
  if (engine !== null &#x26;&#x26; engine.suffix) {
    output += engine.suffix();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.api.bundler.constants" id="apidoc.element.socketstream.api.bundler.constants">
        function <span class="apidocSignatureSpan">socketstream.api.bundler.</span>constants
        <span class="apidocSignatureSpan">(client)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">constants = function (client) {
  var constants = {}, k;

  // mixin system constants
  for(k in system.assets.constants) {
    constants[k] = system.assets.constants[k];
  }

  // mixin client constants
  if (client.constants) {
    for(k in client.constants) {
      constants[k] = describeConstant(k, client.constants[k]);
    }
  }

  function describeConstant(key,value) {
    var desc = { name:key, value:value, type:&#x27;constant&#x27; };
    // perhaps add, value = function support
    return desc;
  }

  // list of constants
  var list = [];
  for(k in constants) {
    constants[k].content = &#x27;var &#x27;+constants[k].name+&#x27;=&#x27;+ JSON.stringify(constants[k].value) +&#x27;;&#x27;;
    list.push(constants[k]);
  }
  return list;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

        var formatter;
        if (engine.selectFormatter) {
formatter = engine.selectFormatter(desc.file, ss.client.formatters, null);
        }

        var opts = {
constants: bundler.<span class="apidocCodeKeywordSpan">constants</span>(),
locals: bundler.locals()
        };

        return bundler.format(desc,
opts, formatter, function(output) {

templates.push(wrapTemplate(output, desc.file, ss.bundler.clientFilePath(desc), opts, options, engine, prevEngine));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.api.bundler.create" id="apidoc.element.socketstream.api.bundler.create">
        function <span class="apidocSignatureSpan">socketstream.api.bundler.</span>create
        <span class="apidocSignatureSpan">(bundler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function create(bundler) {
  var created = Object.create(proto);
  if (bundler) {
    for(var key in bundler) {
      created[key] = bundler[key];
    }
  }
  return created;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    });

    ss.defaultTask(&#x27;load-api&#x27;, function() {
      ss.load();
    });

    ss.defaultTask(&#x27;test-socketstream&#x27;, [&#x27;load-api&#x27;], function() {
      var sessionID = ss.session.<span class="apidocCodeKeywordSpan">create</span>();

      // jshint loopfunc:true
      for (var id in ss.server.responders) {
        if (ss.server.responders.hasOwnProperty(id)) {
var responder = ss.server.responders[id];

if (responder.name &#x26;&#x26; responder.interfaces.internal) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.api.bundler.define" id="apidoc.element.socketstream.api.bundler.define">
        function <span class="apidocSignatureSpan">socketstream.api.bundler.</span>define
        <span class="apidocSignatureSpan">(client, args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function defineBundler(client, args) {

  var name = args[0],
      pathsOrPlugin = args[1],
      bundler;

  if (typeof pathsOrPlugin === &#x22;string&#x22;) {
    bundler = bundlers[name] = ss.require(options.servePacked?&#x27;production&#x27;:args[1],&#x27;client/bundler&#x27;,&#x27;default&#x27;)(ss,client,options
);
    bundler.client = client;
    bundler.define(args[2], args[3], args[4], args[5]);
  } else {
    bundler = bundlers[name] = require(&#x27;./default&#x27;)(ss,client,options); //TODO production bundler switch
    bundler.client = client;
    bundler.define(args[1],args[2]);
  }
  bundler.useLatestsPackedId();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  cp(&#x27;/client/views/app.demo.&#x27; + viewExtension, &#x27;/client/views/app.&#x27; + viewExtension);
  clientFiles.css.push(&#x27;../node_modules/normalize.css/normalize.css&#x27;);
  clientFiles.css.push(&#x27;app.&#x27; + styleExtension);
}

/* Generate app.js */
appjs = &#x27;// My SocketStream 0.4 app\n\nvar ss = require(\&#x27;socketstream\&#x27;);\n\n&#x27;+
        &#x27;// Define a single-page client called \&#x27;main\&#x27;\nss.client.<span class="apidocCodeKeywordSpan">define</span
>(\&#x27;main\&#x27;, {\n  view: \&#x27;app.&#x27; + viewExtension + &#x27;\&#x27;,\n  css:  [\&#x27;&#x27; + (clientFiles.css.join(&#x27;\&#x27;, \&#x27;&#x27;)) + &#x27;\&#x27;],\n  code: [\&#x27;&#x27; + (clientFiles.code.join(&#x27;\&#x27;, \&#x27;&#x27;)) + &#x27;\&#x27;],\n  tmpl: \&#x27;chat\&#x27;\n});\n\n// Serve this client on the root URL\nss.http.route(\&#x27;/\&#x27;, function(req, res){\n  res.serveClient(\&#x27;main\&#x27;);\n});\n&#x27;;

/* List any selected formatters */
if (selectedFormatters.length &#x3e; 0) {
  appjs += &#x27;\n// Code Formatters\n&#x27;;
}
selectedFormatters.forEach(function (name) {
  return appjs += &#x27;ss.client.formatters.add(require(\&#x27;ss-&#x27; + name + &#x27;\&#x27;));\n&#x27;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.api.bundler.destsFor" id="apidoc.element.socketstream.api.bundler.destsFor">
        function <span class="apidocSignatureSpan">socketstream.api.bundler.</span>destsFor
        <span class="apidocSignatureSpan">(client)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">destsFor = function (client) {
  var containerDir = path.join(ss.root, options.dirs.assets);
  var clientDir = path.join(containerDir, client.name);
  var assetsUrl = options.urls.assets;

  return {

    //TODO perhaps mixin the abs versions by SS
    urls: {
      html: assetsUrl + client.name + &#x27;/&#x27; + client.id + &#x27;.html&#x27;,
      js: assetsUrl + client.name + &#x27;/&#x27; + client.id + &#x27;.js&#x27;,
      css: assetsUrl + client.name + &#x27;/&#x27; + client.id + &#x27;.css&#x27;
    },
    paths: {
      html: path.join(clientDir, client.id + &#x27;.html&#x27;),
      js: path.join(clientDir, client.id + &#x27;.js&#x27;),
      css: path.join(clientDir, client.id + &#x27;.css&#x27;)
    },
    relPaths: {
      html: path.join(options.dirs.assets, client.name, client.id + &#x27;.html&#x27;),
      js: path.join(options.dirs.assets, client.name, client.id + &#x27;.js&#x27;),
      css: path.join(options.dirs.assets, client.name, client.id + &#x27;.css&#x27;)
    },
    dir: clientDir,
    containerDir: containerDir
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.api.bundler.entries" id="apidoc.element.socketstream.api.bundler.entries">
        function <span class="apidocSignatureSpan">socketstream.api.bundler.</span>entries
        <span class="apidocSignatureSpan">(client, assetType)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function entries(client, assetType) {

  var _entries = [],
      bundler = getBundler(client),
      includeType,
      bundle;

  switch(assetType) {
    case &#x27;css&#x27;:
      includeType = &#x27;css&#x27;;
      bundle = &#x27;css&#x27;;
      client.paths[&#x27;css&#x27;].forEach(pushMainEntries);
      break;

    case &#x27;js&#x27;:
    case &#x27;worker&#x27;:
      var loader = bundler.module(&#x27;loader&#x27;);
      var libs = bundler.module(&#x27;libs&#x27;);
      var mods = bundler.module.apply(bundler, Object.keys(system.assets.modules));

      _entries = _entries.concat(loader).concat(libs).concat(mods);
      includeType = false;
      bundle = &#x27;js&#x27;;
      //TODO worker instead of code ?
      client.paths.code.forEach(pushMainEntries);
      if (options.startInBundle) {
        _entries = _entries.concat(bundler.module(&#x27;start&#x27;));
      }
      break;

    case &#x27;tmpl&#x27;:
      includeType = &#x27;html&#x27;;
      bundle = &#x27;tmpl&#x27;;
      client.paths.tmpl.forEach(pushMainEntries);
      break;
  }

  function pushMainEntries(from) {
    var p = path.join(ss.root,from);
    if (!fs.existsSync(p) || fs.statSync(p).isFile()) {
      p = from;
    } else {
      p = path.join(from,&#x27;**&#x27;,&#x27;*&#x27;);
    }
    return glob.sync(p, {cwd:ss.root}).forEach(function(file) {
      var extension = path.extname(file);
      extension = extension &#x26;&#x26; extension.substring(1); // argh!
      var assetType = bundle===&#x27;tmpl&#x27;? &#x27;html&#x27;:bundle;
      var entry = {file:file,importedBy:from,includeType:includeType,ext:extension,bundle:bundle,assetType:assetType};
      if (isAssetType(entry)) {
        _entries.push(entry);
      }
    });
  }

  function isAssetType(entry) {
    if (ss.client.formatters == null) {
      return false;
    }
    var formatter = ss.client.formatters[entry.ext];
    if (formatter == null) {
      return false;
    }
    if (formatter.assetType === undefined) {
      throw new Error(&#x27;Unable to render \&#x27;&#x27;+entry.file+&#x27;\&#x27; as the formatter has no asset type.&#x27;);
    }
    return formatter.assetType === entry.assetType;
  }

  // entries with blank ones stripped out
  return _entries.filter(function(entry) {
    return !!entry;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&#x27;use strict&#x27;;

module.exports = function(ss, client, options, cb) {
var templateEngine = require(&#x27;./template_engine&#x27;)(ss, options), //TODO why not use the one in client/index ?
    bundler = ss.bundler.get(client);

function templates() {
  var files = bundler.<span class="apidocCodeKeywordSpan">entries</span>(&#x27;tmpl&#x27;),
      output = [];
  templateEngine.generate(bundler, files, function(html) {
    return output.push(html);
  });
  return output;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.api.bundler.entryFor" id="apidoc.element.socketstream.api.bundler.entryFor">
        function <span class="apidocSignatureSpan">socketstream.api.bundler.</span>entryFor
        <span class="apidocSignatureSpan">(bundle, file, part2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">entryFor = function (bundle, file, part2) {
  var result = {
    bundle: bundle,
    file:file
  };
  if (part2) {
    if (part2.charAt(0) !== &#x27;/&#x27;) {
      part2 = &#x27;/&#x27; + part2;
    }
    result.file = file + part2;
  }

  switch(bundle) {
    case &#x27;tmpl&#x27;:
      result.assetType = &#x27;html&#x27;;
      break;
    case &#x27;worker&#x27;:
      result.assetType = &#x27;js&#x27;;
      break;
  }

  var extension = path.extname(result.file);
  result.ext = extension? extension.substring(1) : (result.assetType || result.bundle);

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    constants: bundler.constants(),
    locals: bundler.locals(),
    headers: includes.join(&#x27;&#x27;),
    tail: start.join(&#x27;&#x27;),
    compress: options.packedAssets,
    filename: client.paths.view
  };
  return bundler.asset(bundler.<span class="apidocCodeKeywordSpan">entryFor</span>(&#x27;html&#x27;,client.paths.view), htmlOptions
, cb);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.api.bundler.findEntryPoint" id="apidoc.element.socketstream.api.bundler.findEntryPoint">
        function <span class="apidocSignatureSpan">socketstream.api.bundler.</span>findEntryPoint
        <span class="apidocSignatureSpan">(client)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findEntryPoint = function (client) {

  var firstIndex, // if no entry point, use first index found
      firstFile;  // if no entry and index, use first file found

  function onlyModuleEntry(f) {
    return f.substring(0,6) === &#x27;entry.&#x27;;
  }
  function onlyModuleIndex(f) {
    return f.substring(0,6) === &#x27;index.&#x27;;
  }
  function diskToRequire(rel) {
    return &#x27;/&#x27; + rel.replace(/\\/g,&#x27;/&#x27;);
  }

  for(var i = 0,rel; (rel = client.paths.code[i]); ++i) {
    var p = path.join(ss.root, rel);
    //TODO if not exists error handling
    if (fs.existsSync(p) &#x26;&#x26; fs.statSync(p).isDirectory()) {

      var files = fs.readdirSync(p);
      var entry = files.filter(onlyModuleEntry);
      if (entry.length) {
        return diskToRequire(rel) + &#x27;/entry&#x27;;
      }
      var index = files.filter(onlyModuleIndex);
      if (index &#x26;&#x26; !firstIndex) {
        firstIndex = diskToRequire(rel) + &#x27;/&#x27;;
      }
    }
    else {
      firstFile = diskToRequire(rel);
      firstFile = firstFile.substring(0, firstFile.length - path.extname(firstFile).length);
    }
  }

  return firstIndex || firstFile;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.api.bundler.forEach" id="apidoc.element.socketstream.api.bundler.forEach">
        function <span class="apidocSignatureSpan">socketstream.api.bundler.</span>forEach
        <span class="apidocSignatureSpan">(fn, that)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forEach = function (fn, that) {
  for(var key in bundlers) {
      var bundler = bundlers[key];
      fn.call(that,bundler,key);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
sh.exec(&#x27;git branch gh-pages origin/gh-pages&#x27; + branch, {silent: true})
        }
    });

    grunt.registerMultiTask(&#x27;shell&#x27;, &#x27;run shell commands&#x27;, function() {
        var self = this;

        self.data.<span class="apidocCodeKeywordSpan">forEach</span>(function(cmd) {
cmd = cmd.replace(&#x27;%version%&#x27;, grunt.file.readJSON(&#x27;package.json&#x27;).version);
grunt.log.ok(cmd);

var result = sh.exec(cmd, { silent: true });

if (result.code !== 0) {
    grunt.fatal(result.output);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.api.bundler.forget" id="apidoc.element.socketstream.api.bundler.forget">
        function <span class="apidocSignatureSpan">socketstream.api.bundler.</span>forget
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forget = function () {
  bundlerById = {};
  bundlers = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.api.bundler.formatKb" id="apidoc.element.socketstream.api.bundler.formatKb">
        function <span class="apidocSignatureSpan">socketstream.api.bundler.</span>formatKb
        <span class="apidocSignatureSpan">(size)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function formatKb(size) {
  return &#x27;&#x27; + (Math.round((size / 1024) * 1000) / 1000) + &#x27; KB&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.api.bundler.get" id="apidoc.element.socketstream.api.bundler.get">
        function <span class="apidocSignatureSpan">socketstream.api.bundler.</span>get
        <span class="apidocSignatureSpan">(client)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getBundler(client){
  if (typeof client === &#x22;string&#x22;) { return bundlers[client]; }

  if (client.bundler) { return client.bundler; }

  if (client.ts) {
    if (bundlerById[client.ts]) {
      return bundlerById[client.ts];
    }
  }
  if (typeof client.client === &#x22;string&#x22;) {
    return bundlers[client.client];
  }
  if (typeof client.name === &#x22;string&#x22;) {
    return bundlers[client.name];
  }

  throw new Error(&#x27;Unknown client &#x27;+(client.name || client.client || client.ts) );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Client Views
// ------------
// Generates HTML output for each single-page view
&#x27;use strict&#x27;;

module.exports = function(ss, client, options, cb) {
var templateEngine = require(&#x27;./template_engine&#x27;)(ss, options), //TODO why not use the one in client/index ?
    bundler = ss.bundler.<span class="apidocCodeKeywordSpan">get</span>(client);

function templates() {
  var files = bundler.entries(&#x27;tmpl&#x27;),
      output = [];
  templateEngine.generate(bundler, files, function(html) {
    return output.push(html);
  });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.api.bundler.injectTailIfNeeded" id="apidoc.element.socketstream.api.bundler.injectTailIfNeeded">
        function <span class="apidocSignatureSpan">socketstream.api.bundler.</span>injectTailIfNeeded
        <span class="apidocSignatureSpan">(output, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">injectTailIfNeeded = function (output, opts) {
  // If passing optional tails for main view
  if (opts &#x26;&#x26; opts.tail &#x26;&#x26; !options.startInBundle) {
    output = output.replace(&#x27;&#x3c;/body&#x3e;&#x27;, opts.tail + &#x27;&#x3c;/body&#x3e;&#x27;);
    output = output.replace(&#x27;&#x3c;/BODY&#x3e;&#x27;, opts.tail + &#x27;&#x3c;/BODY&#x3e;&#x27;);
  }
  return output;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.api.bundler.load" id="apidoc.element.socketstream.api.bundler.load">
        function <span class="apidocSignatureSpan">socketstream.api.bundler.</span>load
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">load = function () {
  var ids = []
  this.forEach(function(bundler) {
    bundlerById[bundler.client.id] = bundler;
    ids.push(bundler.client.id);
    if (bundler.load) {
        bundler.load();
    }
  });
  debug(&#x27;loaded clients %s&#x27;, ids.join(&#x27; &#x27;));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    ss.defaultTask(&#x27;application&#x27;, function() {});

    ss.defaultTask(&#x27;start-server&#x27;,[&#x27;application&#x27;],function(done) {
socketstream.ws.listen(ss.http.settings.port || 3000, done);
    });

    ss.defaultTask(&#x27;load-api&#x27;, function() {
ss.<span class="apidocCodeKeywordSpan">load</span>();
    });

    ss.defaultTask(&#x27;test-socketstream&#x27;, [&#x27;load-api&#x27;], function() {
var sessionID = ss.session.create();

// jshint loopfunc:true
for (var id in ss.server.responders) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.api.bundler.loadFile" id="apidoc.element.socketstream.api.bundler.loadFile">
        function <span class="apidocSignatureSpan">socketstream.api.bundler.</span>loadFile
        <span class="apidocSignatureSpan">(entry, opts, formatter, cb, errCb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function loadFile(entry, opts, formatter, cb, errCb) {
  var type = entry.assetType || entry.bundle;
  formatter = formatter || ss.client.formatters[entry.ext || type];
  if (!formatter) {
    throw new Error(&#x27;Unsupported file extension \&#x27;.&#x27; + entry.ext + &#x27;\&#x27; when we were expecting some type of &#x27; +
      ((type||&#x27;unknown&#x27;).toUpperCase()) + &#x27; file. Please provide a formatter for &#x27; + (entry.file) + &#x27; or move it to /client/static
&#x27;);
  }
  if (formatter.assetType !== type) {
    throw new Error(&#x27;Unable to render \&#x27;&#x27; + entry.file + &#x27;\&#x27; as this appears to be a &#x27; + (type.toUpperCase()) +
      &#x27; file. Expecting some type of &#x27; + (type.toUpperCase()) + &#x27; file in &#x27; + (path.dirname(entry.file)) + &#x27; instead&#x27;);
  }

  // Use the formatter to pre-process the asset before bundling
  try {
    return formatter.call(this.clientFilePath(entry.file), opts, cb, errCb);
  } catch (err) {
    return errCb(err);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.api.bundler.minifyCSS" id="apidoc.element.socketstream.api.bundler.minifyCSS">
        function <span class="apidocSignatureSpan">socketstream.api.bundler.</span>minifyCSS
        <span class="apidocSignatureSpan">(files)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function minifyCSS(files) {
  var origLength = 0;
  var minified = files.map(function(entry){
    origLength += entry.content.length;
    return new CleanCSS().minify(entry.content).styles; // this could also be an async call
  }).join(&#x27;\n&#x27;);
  log.info((&#x27;  Minified CSS from &#x27; + (formatKb(origLength)) + &#x27; to &#x27; + (formatKb(minified.length))).grey);
  return minified;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.api.bundler.minifyJS" id="apidoc.element.socketstream.api.bundler.minifyJS">
        function <span class="apidocSignatureSpan">socketstream.api.bundler.</span>minifyJS
        <span class="apidocSignatureSpan">(files)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function minifyJS_(files) {
  var that = this;
  var min = files.map(function(js) {
    return js.options.minified ? js.content : that.minifyJSFile(js.content);
  });
  return min.join(&#x27;\n&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.api.bundler.minifyJSFile" id="apidoc.element.socketstream.api.bundler.minifyJSFile">
        function <span class="apidocSignatureSpan">socketstream.api.bundler.</span>minifyJSFile
        <span class="apidocSignatureSpan">(originalCode, fileName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function minifyJSFile(originalCode, fileName) {
  var ast = uglifyjs.parse(originalCode, { filename:fileName });
  ast.figure_out_scope();
  ast = ast.transform(compressor);

  ast.figure_out_scope();
  ast.compute_char_frequency();
  ast.mangle_names();
  var minifiedCode = ast.print_to_string();
  if (fileName) {
    log.info((&#x27;  Minified &#x27; + fileName + &#x27; from &#x27; + (formatKb(originalCode.length)) + &#x27; to &#x27; + (formatKb(minifiedCode.length))).
grey);
  }
  return minifiedCode;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.api.bundler.packAssetSet" id="apidoc.element.socketstream.api.bundler.packAssetSet">
        function <span class="apidocSignatureSpan">socketstream.api.bundler.</span>packAssetSet
        <span class="apidocSignatureSpan">(assetType, client, postProcess, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function packAssetSet(assetType, client, postProcess, done) {
  var bundler = getBundler(client);

  // if this goes away, drop async dependency. manage with orchestrator?
  async.mapSeries(bundler.entries(assetType,system.assets), iterator, andThen);

  function iterator(entry, callback) {
    var options = {
      constants: bundler.constants(),
      locals: bundler.locals(),
      //pathPrefix: entry.importedBy,
      compress: true
    };
    if (typeof entry.content === &#x22;string&#x22;) {
      callback(null, {content:entry.content,options:{}});
    }
    else {
      bundler.asset(entry, options, function(output) {
        //TODO if err, flag has errors
        callback(null, {content:output,options:{}});
      });
    }
  }

  function andThen(err, results) {
    var fileName = bundler.dests.paths[assetType];
    fs.writeFileSync(fileName, postProcess(results.filter(function(f) { return f.content &#x26;&#x26; f.content !== &#x27;;&#x27;; })));
    log.info(&#x27;&#x27;.green, &#x27;Packed&#x27;, results.length, &#x27;files into&#x27;, bundler.dests.relPaths[assetType]);
    done();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  done();

  //TODO add the tasks to an async queue that can be asserted on in tests
});

ss.defaultTask(bundler.client.name+&#x27;:pack-css&#x27;, function(done) {
  ss.bundler.<span class="apidocCodeKeywordSpan">packAssetSet</span>(&#x27;css&#x27;, bundler.client, bundler.toMinifiedCSS,done
);
});

ss.defaultTask(bundler.client.name+&#x27;:pack-js&#x27;, function(done) {
  //TODO wait for ss.loaded promise to have socketstream-transport defined
  ss.bundler.packAssetSet(&#x27;js&#x27;, bundler.client, bundler.toMinifiedJS,done);
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.api.bundler.sourcePaths" id="apidoc.element.socketstream.api.bundler.sourcePaths">
        function <span class="apidocSignatureSpan">socketstream.api.bundler.</span>sourcePaths
        <span class="apidocSignatureSpan">(paths)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sourcePaths = function (paths) {

  function relativePath(p, dirType) {
      var relativeStart = p.indexOf(&#x27;./&#x27;) === 0 || p.indexOf(&#x27;../&#x27;) === 0;
      return relativeStart? prefixPath(options.dirs.client,p) : prefixPath(options.dirs[dirType], p);
  }

  function prefixPath(base,p) {
      base = base.replace(/^\//,&#x27;&#x27;);
      if (p === &#x27;*&#x27;) {
        return base;
      }
      p = p.replace(/\/\*$/,&#x27;&#x27;);
      return path.join(base,p);
  }

  function entries(from, dirType) {
    if (from == null) {
      return [];
    }
    var list = (from instanceof Array)? from : [from];

    return list.map(function(value) {
      return relativePath(value, dirType);
    });
  }

  paths.css = entries(paths.css, &#x27;css&#x27;);
  paths.code = entries(paths.code, &#x27;code&#x27;);
  paths.tmpl = entries(paths.tmpl || paths.templates, &#x27;templates&#x27;);

  if (paths.view) {
    paths.view = relativePath(paths.view, &#x27;views&#x27;);
  }

  return paths;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.api.bundler.startCode" id="apidoc.element.socketstream.api.bundler.startCode">
        function <span class="apidocSignatureSpan">socketstream.api.bundler.</span>startCode
        <span class="apidocSignatureSpan">(client)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">startCode = function (client) {
  var startCode = system.assets.startCode.map(function(ic) { return ic.content; }),
    entryInit = client.entryInitPath? &#x27;require(&#x22;&#x27; + client.entryInitPath + &#x27;&#x22;);&#x27; : options.defaultEntryInit;

  if (typeof options.entryModuleName === &#x27;string&#x27; || options.entryModuleName === null) {
    entryInit = options.entryModuleName? &#x27;require(&#x22;/&#x27;+options.entryModuleName+&#x27;&#x22;);&#x27; : &#x27;&#x27;;
  }

  startCode.push(entryInit);

  return [{ content: startCode.join(&#x27;\n&#x27;), options: {}, type: &#x27;start&#x27;, includeType:&#x27;initCode&#x27; }];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.api.bundler.systemLibs" id="apidoc.element.socketstream.api.bundler.systemLibs">
        function <span class="apidocSignatureSpan">socketstream.api.bundler.</span>systemLibs
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">systemLibs = function () {
  var names = [];
  return {
    type: &#x27;mod&#x27;,
    file: &#x27;libs&#x27;,
    includeType: &#x27;system&#x27;,
    names: names,
    content: system.assets.libs.map(function(lib) { names.push(lib.name); return lib.content; }).join(&#x27;\n&#x27;)
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.api.bundler.systemModule" id="apidoc.element.socketstream.api.bundler.systemModule">
        function <span class="apidocSignatureSpan">socketstream.api.bundler.</span>systemModule
        <span class="apidocSignatureSpan">(name, wrap)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function systemModule(name, wrap) {
  name = name.replace(/\.js$/,&#x27;&#x27;);
  var mod = system.assets.modules[name];
  if (mod) {
    var code = wrap===false? mod.content: ss.bundler.wrapModule(name, mod.content);
    return {
      file: mod.name,
      name: mod.name,
      path: mod.path,
      dir: mod.dir,
      content: code,
      options: mod.options,
      type: mod.type,
      includeType: &#x27;system&#x27;
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.api.bundler.systemModules" id="apidoc.element.socketstream.api.bundler.systemModules">
        function <span class="apidocSignatureSpan">socketstream.api.bundler.</span>systemModules
        <span class="apidocSignatureSpan">(wrap)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">systemModules = function (wrap) {
  return Object.keys(system.assets.modules).map(function(name) {
    return systemModule(name,wrap);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.api.bundler.unload" id="apidoc.element.socketstream.api.bundler.unload">
        function <span class="apidocSignatureSpan">socketstream.api.bundler.</span>unload
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unload = function () {
  for(var n in bundlers) {
    if (bundlers[n].unload) {
      bundlers[n].unload();
      bundlers[n].unload = null;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.api.bundler.updateCachedOndemandAssets" id="apidoc.element.socketstream.api.bundler.updateCachedOndemandAssets">
        function <span class="apidocSignatureSpan">socketstream.api.bundler.</span>updateCachedOndemandAssets
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function UpdateCachedOndemandAssets() {

  var files = glob.sync(&#x27;**/*.js&#x27;, {cwd: path.join(ss.root,options.dirs.code)}); //TODO need root *.js as well
  files.forEach(function(rel) {
    ss.http.cached.route(&#x27;assets/ondemand/&#x27;+ (rel.replace(&#x27;\\&#x27;,&#x27;/&#x27;)), null, path.join(ss.root, options.dirs.code, rel) );
  },this);

  files = glob.sync(&#x27;**/*.js&#x27;, {cwd: path.join(ss.root,options.dirs.workers)}); //TODO need root *.js as well
  files.forEach(function(rel) {
    ss.http.cached.route(&#x27;assets/workers/&#x27;+ (rel.replace(&#x27;\\&#x27;,&#x27;/&#x27;)), null, path.join(ss.root, options.dirs.workers, rel) );
  },this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
}
    });

    // task: ondemand
    // Listen out for requests to async load new assets
    ss.defaultTask(&#x27;serve&#x27;, function serveOndemand(done) {
ss.bundler.<span class="apidocCodeKeywordSpan">updateCachedOndemandAssets</span>(); //TODO pipe to cache

socketstream.ws.listen(ss.http.settings.port || 3000);

// Send server instance to any registered modules (e.g. console)
ss.events.emit(&#x27;server:start&#x27;, ss.server);

process.on(&#x27;exit&#x27;, function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.api.bundler.wrapModule" id="apidoc.element.socketstream.api.bundler.wrapModule">
        function <span class="apidocSignatureSpan">socketstream.api.bundler.</span>wrapModule
        <span class="apidocSignatureSpan">(modPath, code)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">wrapModule = function (modPath, code) {
  return &#x27;require.define(&#x22;&#x27; + modPath + &#x27;&#x22;, function (require, module, exports, __dirname, __filename){\n&#x27; + code + &#x27;\n});&#x27;+
  &#x27;&#x27;;
        //TODO  &#x27;\n//# sourceMappingURL=&#x27;+modPath+&#x27;.js\n&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.socketstream.api.client" id="apidoc.module.socketstream.api.client">module socketstream.api.client</a></h1>


    <h2>
        <a href="#apidoc.element.socketstream.api.client.send" id="apidoc.element.socketstream.api.client.send">
        function <span class="apidocSignatureSpan">socketstream.api.client.</span>send
        <span class="apidocSignatureSpan">(type, name, content, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">send = function (type, name, content, options) {
  if (options === null || options === undefined) {
    options = {};
  }

  switch (type) {
    case &#x27;const&#x27;:
    case &#x27;constant&#x27;:
      //jshint -W093
      return (assets.constants[name] = {value:content,name:name,type:&#x27;const&#x27;,options:options});
    case &#x27;local&#x27;:
      //jshint -W093
      return (assets.locals[name] = { value:content,name:name,type:type,options:options});
    case &#x27;start&#x27;:
    case &#x27;code&#x27;:
      return assets.startCode.push({content:content,options:options, type:&#x27;start&#x27;});
    case &#x27;lib&#x27;:
    case &#x27;library&#x27;:
      return pushUniqueAsset(&#x27;libs&#x27;,{
        name: name,
        type: &#x27;lib&#x27;,
        dir: pathlib.join(__dirname,&#x27;libs&#x27;),
        path: pathlib.join(__dirname,&#x27;libs&#x27;,name + &#x27;.js&#x27;),
        content: content,
        options: options
      });
    case &#x27;mod&#x27;:
    case &#x27;module&#x27;:
      if (assets.modules[name]) {
        throw new Error(&#x27;System module name \&#x27;&#x27; + name + &#x27;\&#x27; already exists&#x27;);
      } else {
        name = name.replace(/\.js$/,&#x27;&#x27;);
        assets.modules[name] = {
          name: name,
          type: &#x27;mod&#x27;,
          dir: pathlib.join(__dirname,&#x27;modules&#x27;),
          path: pathlib.join(__dirname,&#x27;modules&#x27;,name + &#x27;.js&#x27;),
          content: content,
          options: options
        };
        return assets.modules[name];
      }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.socketstream.api.log" id="apidoc.module.socketstream.api.log">module socketstream.api.log</a></h1>


    <h2>
        <a href="#apidoc.element.socketstream.api.log.clientIssue" id="apidoc.element.socketstream.api.log.clientIssue">
        function <span class="apidocSignatureSpan">socketstream.api.log.</span>clientIssue
        <span class="apidocSignatureSpan">(client, options, err, more)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function clientIssue(client, options, err, more) {
  var info = [&#x27;&#x27;];
  if (options.serveDebugInfo) {
    err.userInfo = info;
  }
  info.push(err.message);
  info.push(&#x27;client=&#x27;+client.id);
  if (err.stack) {
    info = info.concat(err.stack.split(&#x27;\n&#x27;).splice(1));
  }
  if (more) {
    info.push(&#x27;more:&#x27;);
    info.push(JSON.stringify(more));
  }

  var number = nextClientIssue++;

  Object.defineProperty(err, &#x27;userInfoHTML&#x27;, {
    get: function() {
      return this.userInfo? this.userInfo.join(&#x27;&#x3c;br&#x3e;&#x27;) : &#x27; issue=&#x27;+number;
    }
  });
  Object.defineProperty(err, &#x27;userInfoText&#x27;, {
    get: function() {
      return this.userInfo? this.userInfo.join(&#x27;\n&#x27;) : &#x27; issue=&#x27;+number;
    }
  });

  this.error((&#x27;Couldn\&#x27;t serve client &#x27;+client.name+&#x27;,&#x27;).red, &#x27;issue=&#x27;+number, info.join(&#x27;\n&#x27;));

  return number;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
          output = templates.join(&#x27;&#x27;);
          if (engine !== null &#x26;&#x26; engine.suffix) {
            output += engine.suffix();
          }
          return cb(output);
        }
      }, function(err) {
        ss.log.<span class="apidocCodeKeywordSpan">clientIssue</span>(client,options,err,desc);
        return cb(&#x27;Couldn\&#x27;t format &#x27; + desc.file + err.userInfoHTML);
      });
    });
  }
};

// private
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.api.log.debug" id="apidoc.element.socketstream.api.log.debug">
        function <span class="apidocSignatureSpan">socketstream.api.log.</span>debug
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">debug = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.api.log.error" id="apidoc.element.socketstream.api.log.error">
        function <span class="apidocSignatureSpan">socketstream.api.log.</span>error
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">error = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    result = sh.exec(&#x27;git symbolic-ref HEAD&#x27;, {silent: true});
    if (result.output.trim() !== &#x27;refs/heads/&#x27; + branch) {
        throw new Error(&#x27;Not on master branch, aborting! Current branch is \&#x27;&#x27; + result.output.trim() + &#x27;\&#
x27;&#x27;);
    }

    result = sh.exec(&#x27;git status --porcelain&#x27;, {silent: true});
    if (result.output.trim() !== &#x27;&#x27;) {
        grunt.log.<span class="apidocCodeKeywordSpan">error</span>(result.output.trim());
        throw new Error(&#x27;Working copy is dirty, aborting!&#x27;);
    }
});

grunt.registerTask(&#x27;is-gh-pages-branch-exist&#x27;, &#x27;Check if gh-pages branch exists, if not create it&#x27;, function
() {
    var result,
        branch = this.args[0];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.api.log.info" id="apidoc.element.socketstream.api.log.info">
        function <span class="apidocSignatureSpan">socketstream.api.log.</span>info
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">info = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			}
    }

    // assumed to be dev time frame, if this is to be used for production it should be enhanced
    function set(url, content, mimeType) {
			if (url.charAt(0) !== &#x27;/&#x27;) { url = &#x27;/&#x27;+url; }
			var point = getPoint(url) || new KnownPoint(url);
			// console.<span class="apidocCodeKeywordSpan">info</span>(&#x27;new url:&#x27;,url, mimeType);
			point.content = content;
			point.mimeType = mimeType;
    }

	function cachedMiddleware(req, res, next) {
		var point = getPoint(req);
		// console.log(&#x27;cmw&#x27;,point,req.url);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.api.log.trace" id="apidoc.element.socketstream.api.log.trace">
        function <span class="apidocSignatureSpan">socketstream.api.log.</span>trace
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">trace = function () {
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.api.log.warn" id="apidoc.element.socketstream.api.log.warn">
        function <span class="apidocSignatureSpan">socketstream.api.log.</span>warn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">warn = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.socketstream.api.require" id="apidoc.module.socketstream.api.require">module socketstream.api.require</a></h1>


    <h2>
        <a href="#apidoc.element.socketstream.api.require.require" id="apidoc.element.socketstream.api.require.require">
        function <span class="apidocSignatureSpan">socketstream.api.</span>require
        <span class="apidocSignatureSpan">(id, contextPath, defaultId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function requires(id, contextPath, defaultId) {
		var context, callback;
		if (typeof defaultId === &#x27;function&#x27;) {
			callback = defaultId;
			defaultId = null;
		}
		if (contextPath) {
			context = contexts[contextPath];
			if (context === undefined) {
				context = contexts[contextPath] = {
					rel : context,
					prefix: path.join(__dirname, &#x27;..&#x27;, contextPath),
					inContext: function(id) {
						try {
							var p = path.join(context.prefix,id);
							if (require.resolve(p)) { // gives full path
								return require(p);
							}
						} catch(ex) {}
					}
				};
			}
    }

    switch(typeof id) {
      case &#x27;object&#x27;:
      case &#x27;function&#x27;:
        if (id) {
          return id; // straight object/function will just resolve straight away
        }
        break;
      case &#x27;string&#x27;:
        if (context) {
          // builtin modules take first priority
          var inContext = context.inContext(id);
          if (inContext) { return inContext; }

        }

        // if relative base on main script location
        if (id.charAt(0) === &#x27;.&#x27;) {
          var inProject = path.join(ss.root,id);
          if (fs.existsSync(inProject+&#x27;.js&#x27;)) {
            debug(&#x27;found &#x27;+id);
            return require(inProject);
          }
        }

        // getting a packaged module
        var mod = projectOrHereRequire(id,ss.root);
        if (mod) {
          debug(&#x27;found &#x27;+id+&#x27; in project or SocketStream&#x27;);
          return require(mod);
        }
        break;
    }

		if (context &#x26;&#x26; defaultId) {
			// default looked up in context first
			var defaultInContext = context.inContext(defaultId);
			if (defaultInContext) { return defaultInContext; }

			// all bets are off
			mod = projectOrHereRequire(defaultId,ss.root);
			if (mod) {
				debug(&#x27;found &#x27;+defaultId+&#x27; in project or SocketStream&#x27;);
				return require(mod);
			}
		}

		if (callback) {
			return callback({
				id:id
			});
		}
		throw new Error(&#x27;Cannot find module &#x22;&#x27; + id + &#x27;&#x22; in socketstream or project&#x27;);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...



// Entry point for app.js
&#x27;use strict&#x27;;

var ss = require(&#x27;./lib/socketstream.js&#x27;),
  express = ss.api.<span class="apidocCodeKeywordSpan">require</span>(&#x27;express&#x27;);

module.exports = function() {
var app = ss.http.middleware = express();

app.listen = function() {
  ss.ws.listen.apply(ss.ws, arguments);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.api.require.forEach" id="apidoc.element.socketstream.api.require.forEach">
        function <span class="apidocSignatureSpan">socketstream.api.require.</span>forEach
        <span class="apidocSignatureSpan">(pattern, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function forEach(pattern, fn) {
		var packageJSON = findup(&#x27;package.json&#x27;, {cwd:ss.root});
		if (packageJSON) {
			var dependencies = require(packageJSON).dependencies;
			dependencies = dependencies? Object.keys(dependencies) : [];
			var matches = micromatch(dependencies,pattern);
			var mod = {};
			matches.forEach(function(id) {
				if (mod[id] === undefined) {
					try {
						mod[id] = resolve.sync(id, { package: packageJSON, basedir: ss.root});
						debug(&#x27;matched &#x27;+id+&#x27; from pattern &#x27;+pattern);
						fn(require(mod[id]),id);
					} catch(ex) {
						//TODO debug log failed to use SocketStream Add-On
					}
				}
			});
		}
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
sh.exec(&#x27;git branch gh-pages origin/gh-pages&#x27; + branch, {silent: true})
        }
    });

    grunt.registerMultiTask(&#x27;shell&#x27;, &#x27;run shell commands&#x27;, function() {
        var self = this;

        self.data.<span class="apidocCodeKeywordSpan">forEach</span>(function(cmd) {
cmd = cmd.replace(&#x27;%version%&#x27;, grunt.file.readJSON(&#x27;package.json&#x27;).version);
grunt.log.ok(cmd);

var result = sh.exec(cmd, { silent: true });

if (result.code !== 0) {
    grunt.fatal(result.output);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.api.require.resolve" id="apidoc.element.socketstream.api.require.resolve">
        function <span class="apidocSignatureSpan">socketstream.api.require.</span>resolve
        <span class="apidocSignatureSpan">(id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function resolves(id) {
		return projectOrHereRequire(id,ss.root);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  config = cfg;
  transport = (function() {
    if (typeof nameOrModule === &#x27;function&#x27;) {
      return nameOrModule;
    } else {
      modPath = &#x27;./transports/&#x27; + nameOrModule;
      if (require.<span class="apidocCodeKeywordSpan">resolve</span>(modPath)) {
        return require(modPath);
      } else {
        throw new Error(&#x27;Unable to find Publish Event Transport \&#x27;&#x27; + nameOrModule + &#x27;\&#x27; internally. Please
 pass a module&#x27;);
      }
    }
  })();
},
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.socketstream.client" id="apidoc.module.socketstream.client">module socketstream.client</a></h1>


    <h2>
        <a href="#apidoc.element.socketstream.client.define" id="apidoc.element.socketstream.client.define">
        function <span class="apidocSignatureSpan">socketstream.client.</span>define
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">define = function (name) {
  if (clients[name]) {
    throw new Error(&#x27;Client name \&#x27;&#x27; + name + &#x27;\&#x27; has already been defined&#x27;);
  }
  // if a function is used construct a bundler with it otherwise use default bundler
  var client = clients[name] = {
    name: name,
    paths: {},
    uniqueId: shortid.generate(),
    includes: {
      css: true,
      html: true,
      system: true,
      initCode: true
    }
  };
  client.id = client.uniqueId;

  ss.bundler.define(client,arguments);

  return client;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  cp(&#x27;/client/views/app.demo.&#x27; + viewExtension, &#x27;/client/views/app.&#x27; + viewExtension);
  clientFiles.css.push(&#x27;../node_modules/normalize.css/normalize.css&#x27;);
  clientFiles.css.push(&#x27;app.&#x27; + styleExtension);
}

/* Generate app.js */
appjs = &#x27;// My SocketStream 0.4 app\n\nvar ss = require(\&#x27;socketstream\&#x27;);\n\n&#x27;+
        &#x27;// Define a single-page client called \&#x27;main\&#x27;\nss.client.<span class="apidocCodeKeywordSpan">define</span
>(\&#x27;main\&#x27;, {\n  view: \&#x27;app.&#x27; + viewExtension + &#x27;\&#x27;,\n  css:  [\&#x27;&#x27; + (clientFiles.css.join(&#x27;\&#x27;, \&#x27;&#x27;)) + &#x27;\&#x27;],\n  code: [\&#x27;&#x27; + (clientFiles.code.join(&#x27;\&#x27;, \&#x27;&#x27;)) + &#x27;\&#x27;],\n  tmpl: \&#x27;chat\&#x27;\n});\n\n// Serve this client on the root URL\nss.http.route(\&#x27;/\&#x27;, function(req, res){\n  res.serveClient(\&#x27;main\&#x27;);\n});\n&#x27;;

/* List any selected formatters */
if (selectedFormatters.length &#x3e; 0) {
  appjs += &#x27;\n// Code Formatters\n&#x27;;
}
selectedFormatters.forEach(function (name) {
  return appjs += &#x27;ss.client.formatters.add(require(\&#x27;ss-&#x27; + name + &#x27;\&#x27;));\n&#x27;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.client.forget" id="apidoc.element.socketstream.client.forget">
        function <span class="apidocSignatureSpan">socketstream.client.</span>forget
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forget = function () {
    clients = {};
    setDefaultOptions(options);
    systemAssets.unload();
    ss.bundler.forget();
    if (this.templateEngine) { this.templateEngine.forget(); this.templateEngine = null; }
    if (this.formatters) { this.formatters.forget(); this.formatters = null; }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.client.init" id="apidoc.element.socketstream.client.init">
        function <span class="apidocSignatureSpan">socketstream.client.</span>init
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">init = function () {
  this.templateEngine = this.templateEngine || require(&#x27;./template_engine&#x27;)(ss,options);

  if (this.formatters == null) {
    this.formatters = require(&#x27;./formatters&#x27;)(ss,options);

    // Load default code formatters
    this.formatters.add(&#x27;javascript&#x27;);
    this.formatters.add(&#x27;css&#x27;);
    this.formatters.add(&#x27;html&#x27;);
    this.formatters.add(&#x27;map&#x27;);
  }

  systemAssets.load();

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     * @param {object} config parameters configuring the formatter
     */
    add: function(nameOrModule, config) {
      var formatter;
      config = config || {};
      switch(typeof nameOrModule) {
case &#x27;object&#x27;:
  formatter = nameOrModule.<span class="apidocCodeKeywordSpan">init</span>(ss.root, config, options);
  addCall(formatter);
  break;

case &#x27;function&#x27;:
case &#x27;string&#x27;:
  var mod = ss.require(nameOrModule, &#x27;client/formatters&#x27;,function(err) {
    throw new Error(&#x27;The &#x22;&#x27;+err.id+&#x27;&#x22; formatter is not supported by &#x27;+
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.client.load" id="apidoc.element.socketstream.client.load">
        function <span class="apidocSignatureSpan">socketstream.client.</span>load
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">load = function () {
  if (options.servePacked) {
    ss.bundler.forEach(function(bundler) {
      bundler.useLatestsPackedId();
    });
  }
  ss.bundler.load();
  //TODO convert options.dirs to relative paths stripping the lead &#x27;/&#x27; if present

  // Cache instances of code formatters and template engines here
  // This may change in the future as I don&#x27;t like hanging system objects
  // on the &#x27;ss&#x27; internal API object, but for now it solves a problem
  // we were having when repl.start() would erase vars cached inside a module
  ss.client.formatters = this.formatters.load();
  ss.client.templateEngines = this.templateEngine.load();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    ss.defaultTask(&#x27;application&#x27;, function() {});

    ss.defaultTask(&#x27;start-server&#x27;,[&#x27;application&#x27;],function(done) {
socketstream.ws.listen(ss.http.settings.port || 3000, done);
    });

    ss.defaultTask(&#x27;load-api&#x27;, function() {
ss.<span class="apidocCodeKeywordSpan">load</span>();
    });

    ss.defaultTask(&#x27;test-socketstream&#x27;, [&#x27;load-api&#x27;], function() {
var sessionID = ss.session.create();

// jshint loopfunc:true
for (var id in ss.server.responders) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.client.packAssets" id="apidoc.element.socketstream.client.packAssets">
        function <span class="apidocSignatureSpan">socketstream.client.</span>packAssets
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">packAssets = function (opts) {
  if (opts &#x26;&#x26; typeof opts !== &#x27;object&#x27;) {
    throw new Error(&#x27;Options passed to ss.client.packAssets() must be an object&#x27;);
  }
  options.packedAssets = opts || true;
  options.servePacked = opts || true;
  options.liveReload = false;

  // As it&#x27;s safe to assume we&#x27;re running in production mode at this point, if your app is not catching uncaught
  // errors with its own custom error handling code, step in and prevent any exceptions from taking the server down
  if (options.packedAssets &#x26;&#x26; process.listeners(&#x27;uncaughtException&#x27;).length === 0) {
    return process.on(&#x27;uncaughtException&#x27;, function(err) {
      log.error(&#x27;Uncaught Exception!&#x27;.red);
      return log.error(err.stack);
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  appjs += &#x27;\n// Code Formatters\n&#x27;;
}
selectedFormatters.forEach(function (name) {
  return appjs += &#x27;ss.client.formatters.add(require(\&#x27;ss-&#x27; + name + &#x27;\&#x27;));\n&#x27;;
});
appjs += &#x27;\n// Use server-side compiled Hogan (Mustache) templates. Others engines available\n&#x27;+
         &#x27;ss.client.templateEngine.use(require(\&#x27;ss-hogan\&#x27;));\n\n// Minimize and pack assets if you type: SS_ENV
=production node app.js\n&#x27;+
         &#x27;if (ss.env === \&#x27;production\&#x27;) ss.client.<span class="apidocCodeKeywordSpan">packAssets</span>();\n&#x27
;;
if (program.repl) {
  appjs += &#x27;\n// Start Console Server (REPL)\n// To install client: sudo npm install -g ss-console\n&#x27;+
           &#x27;// To connect: ss-console &#x3c;optional_host_or_port&#x3e;\nvar consoleServer = require(\&#x27;ss-console\&#x27
;)(ss);\nconsoleServer.listen(5000);\n&#x27;;
}
appjs += &#x27;\n// Start SocketStream\nss.start();&#x27;;
write(&#x27;/app.js&#x27;, appjs);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.client.reloadCached" id="apidoc.element.socketstream.client.reloadCached">
        function <span class="apidocSignatureSpan">socketstream.client.</span>reloadCached
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reloadCached = function () {
  ss.http.cached.loadStatic();
  ss.http.cached.loadAssets();
  ss.bundler.updateCachedOndemandAssets();

  ss.bundler.forEach(function(bundler) {
    bundler.updateCachedDevAssets();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.client.reloadClients" id="apidoc.element.socketstream.client.reloadClients">
        function <span class="apidocSignatureSpan">socketstream.client.</span>reloadClients
        <span class="apidocSignatureSpan">(changedPath, event)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reloadClients(changedPath, event) {
   var customOnChange = options.onChange || {},
       delayTime = customOnChange.delayTime || 100,
       guardTime = customOnChange.guardTime || 1000;

   function onChangeFiltered(path, event,action) {
       ss.log.info(&#x27;&#x27;.green, consoleMessage[action].grey);
       var pubs =&#x27;__ss:&#x27; + action;
       if (customOnChange.publish) {
           pubs = options.onChange.publish(path, event,action,pubs);
       }
       if (pubs) {
           ss.publish.all(pubs);
       }

       lastRun[action].at = Date.now();
   }

   // reload the browser
   function onChange(changedPath, event) {
     var _ref = path.extname(changedPath),
         action = cssExtensions.indexOf(_ref) &#x3e;= 0 ? &#x27;updateCSS&#x27; : &#x27;reload&#x27;;
     //first change is with delayTime delay , thereafter only once there has been no further changes for guardTime seconds

     //validate the change
     if (customOnChange.validate) {
         if (!customOnChange.validate(changedPath, event,action)) { return ;} //ignore changes if the app says-so
     }

     //avoid multiple rapid changes
     var delay=delayTime;
     if (lastRun[action].guardTime) { clearTimeout(lastRun[action].guardTime); delay=guardTime;}
     if (lastRun[action].delayTime) { clearTimeout(lastRun[action].delayTime); delay=delayTime;}
     lastRun[action].delayTime = setTimeout(function(){
         onChangeFiltered(changedPath, event, action);
         lastRun[action].guardTime = setTimeout(function(){
             lastRun[action].guardTime=null;
             }, delay);
          lastRun[action].delayTime=null;
         }, delay);

     return Date.now();
   }

   return onChange(changedPath, event);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.client.servePacked" id="apidoc.element.socketstream.client.servePacked">
        function <span class="apidocSignatureSpan">socketstream.client.</span>servePacked
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">servePacked = function (opts) {
  if (opts &#x26;&#x26; typeof opts !== &#x27;object&#x27;) {
    throw new Error(&#x27;Options passed to ss.client.servePacked() must be an object&#x27;);
  }
  options.servePacked = opts || true;
  options.liveReload = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.client.set" id="apidoc.element.socketstream.client.set">
        function <span class="apidocSignatureSpan">socketstream.client.</span>set
        <span class="apidocSignatureSpan">(newOption)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">set = function (newOption) {
  var k, v, y, _results;
  if (typeof newOption !== &#x27;object&#x27;) {
    throw new Error(&#x27;ss.client.set() takes an object e.g. {liveReload: false}&#x27;);
  }
  _results = [];
  for (k in newOption) {
    if (newOption.hasOwnProperty(k)) {
      v = newOption[k];
      if (v instanceof Object) {
        //jshint -W083
        _results.push((function() {
          var _results1, x;
          _results1 = [];
          for (x in v) {
            if (v.hasOwnProperty(x)) {
              y = v[x];

              if (!options[k]) {
                options[k]= {};
              }

              _results1.push(options[k][x] = y);
            }
          }
          return _results1;
        })());
      } else {
        _results.push(options[k] = v);
      }
    }
  }
  return _results;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  app.socketstream = function( fn(req,stream) )

  app.stream = ss.http.stream;
  */
  app.stream = ss.http.stream;

  if (ss.env === &#x27;development&#x27;) {
app.<span class="apidocCodeKeywordSpan">set</span>(&#x27;views&#x27;, ss.client.dirs.views);
// Showing stack errors
app.set(&#x27;showStackError&#x27;, true);
// Disable views cache
app.set(&#x27;view cache&#x27;, false);

// Environment dependent middleware
// throws cannot find stack
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.client.task" id="apidoc.element.socketstream.client.task">
        function <span class="apidocSignatureSpan">socketstream.client.</span>task
        <span class="apidocSignatureSpan">(client, name, dependents, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">task = function (client, name, dependents, fn) {
  // should dependents be translated for other client tasks? Perhaps identify global tasks by a prefix or by lookup
  dependents = dependents.map(function(task) {
    return client+&#x27;:&#x27;+task;
  });
  ss.tasks.add(client+&#x27;:&#x27;+name, dependents, fn);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.client.unload" id="apidoc.element.socketstream.client.unload">
        function <span class="apidocSignatureSpan">socketstream.client.</span>unload
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unload = function () {
  ss.client.formatters = {};
  ss.client.templateEngines = {};
  ss.bundler.unload();
  systemAssets.unload();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.socketstream.client.assets" id="apidoc.module.socketstream.client.assets">module socketstream.client.assets</a></h1>


    <h2>
        <a href="#apidoc.element.socketstream.client.assets.load" id="apidoc.element.socketstream.client.assets.load">
        function <span class="apidocSignatureSpan">socketstream.client.assets.</span>load
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">load = function () {
  if (assets.modules[&#x27;eventemitter2&#x27;]) {return;}

  // System Modules. Including main SocketStream client code
  // Load order is not important
  var modDir = pathlib.join(__dirname, &#x27;/modules&#x27;);
  fsUtils.readDirSync(modDir).files.forEach(function(fileName) {
    var code = fs.readFileSync(fileName, &#x27;utf8&#x27;);
    var sp = fileName.split(&#x27;.&#x27;);
    var extension = sp[sp.length - 1];
    var modName = fileName.substr(modDir.length + 1).replace(&#x27;.js&#x27;,&#x27;&#x27;).replace(&#x27;.min.js&#x27;,&#x27;&#x27;);
    return send(&#x27;mod&#x27;, modName, code, {
      coffee: extension === &#x27;coffee&#x27;
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    ss.defaultTask(&#x27;application&#x27;, function() {});

    ss.defaultTask(&#x27;start-server&#x27;,[&#x27;application&#x27;],function(done) {
socketstream.ws.listen(ss.http.settings.port || 3000, done);
    });

    ss.defaultTask(&#x27;load-api&#x27;, function() {
ss.<span class="apidocCodeKeywordSpan">load</span>();
    });

    ss.defaultTask(&#x27;test-socketstream&#x27;, [&#x27;load-api&#x27;], function() {
var sessionID = ss.session.create();

// jshint loopfunc:true
for (var id in ss.server.responders) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.client.assets.send" id="apidoc.element.socketstream.client.assets.send">
        function <span class="apidocSignatureSpan">socketstream.client.assets.</span>send
        <span class="apidocSignatureSpan">(type, name, content, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">send = function (type, name, content, options) {
  if (options === null || options === undefined) {
    options = {};
  }

  switch (type) {
    case &#x27;const&#x27;:
    case &#x27;constant&#x27;:
      //jshint -W093
      return (assets.constants[name] = {value:content,name:name,type:&#x27;const&#x27;,options:options});
    case &#x27;local&#x27;:
      //jshint -W093
      return (assets.locals[name] = { value:content,name:name,type:type,options:options});
    case &#x27;start&#x27;:
    case &#x27;code&#x27;:
      return assets.startCode.push({content:content,options:options, type:&#x27;start&#x27;});
    case &#x27;lib&#x27;:
    case &#x27;library&#x27;:
      return pushUniqueAsset(&#x27;libs&#x27;,{
        name: name,
        type: &#x27;lib&#x27;,
        dir: pathlib.join(__dirname,&#x27;libs&#x27;),
        path: pathlib.join(__dirname,&#x27;libs&#x27;,name + &#x27;.js&#x27;),
        content: content,
        options: options
      });
    case &#x27;mod&#x27;:
    case &#x27;module&#x27;:
      if (assets.modules[name]) {
        throw new Error(&#x27;System module name \&#x27;&#x27; + name + &#x27;\&#x27; already exists&#x27;);
      } else {
        name = name.replace(/\.js$/,&#x27;&#x27;);
        assets.modules[name] = {
          name: name,
          type: &#x27;mod&#x27;,
          dir: pathlib.join(__dirname,&#x27;modules&#x27;),
          path: pathlib.join(__dirname,&#x27;modules&#x27;,name + &#x27;.js&#x27;),
          content: content,
          options: options
        };
        return assets.modules[name];
      }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.client.assets.unload" id="apidoc.element.socketstream.client.assets.unload">
        function <span class="apidocSignatureSpan">socketstream.client.assets.</span>unload
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unload = function () {
  assets.libs = [];
  assets.modules = {};
  assets.constants = {};
  assets.startCode = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.socketstream.client.formatters" id="apidoc.module.socketstream.client.formatters">module socketstream.client.formatters</a></h1>


    <h2>
        <a href="#apidoc.element.socketstream.client.formatters.add" id="apidoc.element.socketstream.client.formatters.add">
        function <span class="apidocSignatureSpan">socketstream.client.formatters.</span>add
        <span class="apidocSignatureSpan">(nameOrModule, config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">add = function (nameOrModule, config) {
  var formatter;
  config = config || {};
  switch(typeof nameOrModule) {
    case &#x27;object&#x27;:
      formatter = nameOrModule.init(ss.root, config, options);
      addCall(formatter);
      break;

    case &#x27;function&#x27;:
    case &#x27;string&#x27;:
      var mod = ss.require(nameOrModule, &#x27;client/formatters&#x27;,function(err) {
        throw new Error(&#x27;The &#x22;&#x27;+err.id+&#x27;&#x22; formatter is not supported by &#x27;+
                &#x27;SocketStream internally. Please pass a compatible module instead&#x27;);
      });
      formatter = mod(ss, config, options);
      addCall(formatter,true);
      break;
  }

  return mods.push(formatter);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        &#x27;// Define a single-page client called \&#x27;main\&#x27;\nss.client.define(\&#x27;main\&#x27;, {\n  view: \&#x27;app
.&#x27; + viewExtension + &#x27;\&#x27;,\n  css:  [\&#x27;&#x27; + (clientFiles.css.join(&#x27;\&#x27;, \&#x27;&#x27;)) + &#x27;\&#x27;],\n  code: [\&#x27;&#x27; + (clientFiles.code.join(&#x27;\&#x27;, \&#x27;&#x27;)) + &#x27;\&#x27;],\n  tmpl: \&#x27;chat\&#x27;\n});\n\n// Serve this client on the root URL\nss.http.route(\&#x27;/\&#x27;, function(req, res){\n  res.serveClient(\&#x27;main\&#x27;);\n});\n&#x27;;

/* List any selected formatters */
if (selectedFormatters.length &#x3e; 0) {
  appjs += &#x27;\n// Code Formatters\n&#x27;;
}
selectedFormatters.forEach(function (name) {
  return appjs += &#x27;ss.client.formatters.<span class="apidocCodeKeywordSpan">add</span>(require(\&#x27;ss-&#x27; + name + &#
x27;\&#x27;));\n&#x27;;
});
appjs += &#x27;\n// Use server-side compiled Hogan (Mustache) templates. Others engines available\n&#x27;+
         &#x27;ss.client.templateEngine.use(require(\&#x27;ss-hogan\&#x27;));\n\n// Minimize and pack assets if you type: SS_ENV
=production node app.js\n&#x27;+
         &#x27;if (ss.env === \&#x27;production\&#x27;) ss.client.packAssets();\n&#x27;;
if (program.repl) {
  appjs += &#x27;\n// Start Console Server (REPL)\n// To install client: sudo npm install -g ss-console\n&#x27;+
           &#x27;// To connect: ss-console &#x3c;optional_host_or_port&#x3e;\nvar consoleServer = require(\&#x27;ss-console\&#x27
;)(ss);\nconsoleServer.listen(5000);\n&#x27;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.client.formatters.forget" id="apidoc.element.socketstream.client.formatters.forget">
        function <span class="apidocSignatureSpan">socketstream.client.formatters.</span>forget
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forget = function () {
  mods.length = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.client.formatters.load" id="apidoc.element.socketstream.client.formatters.load">
        function <span class="apidocSignatureSpan">socketstream.client.formatters.</span>load
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">load = function () {
  var byExtension = {};
  mods.forEach(function (mod) {
    return mod.extensions.forEach(function (extension) {
      byExtension[extension] = mod;
    });
  });
  debug(&#x27;Formatters supported by extension: %s&#x27;, Object.keys(byExtension).join(&#x27;,&#x27;));
  return byExtension;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    ss.defaultTask(&#x27;application&#x27;, function() {});

    ss.defaultTask(&#x27;start-server&#x27;,[&#x27;application&#x27;],function(done) {
socketstream.ws.listen(ss.http.settings.port || 3000, done);
    });

    ss.defaultTask(&#x27;load-api&#x27;, function() {
ss.<span class="apidocCodeKeywordSpan">load</span>();
    });

    ss.defaultTask(&#x27;test-socketstream&#x27;, [&#x27;load-api&#x27;], function() {
var sessionID = ss.session.create();

// jshint loopfunc:true
for (var id in ss.server.responders) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.socketstream.client.templateEngine" id="apidoc.module.socketstream.client.templateEngine">module socketstream.client.templateEngine</a></h1>


    <h2>
        <a href="#apidoc.element.socketstream.client.templateEngine.forget" id="apidoc.element.socketstream.client.templateEngine.forget">
        function <span class="apidocSignatureSpan">socketstream.client.templateEngine.</span>forget
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forget = function () {
  mods.length = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.client.templateEngine.generate" id="apidoc.element.socketstream.client.templateEngine.generate">
        function <span class="apidocSignatureSpan">socketstream.client.templateEngine.</span>generate
        <span class="apidocSignatureSpan">(bundler, files, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">generate = function (bundler, files, cb) {
  var prevEngine = null;
  var templates = [];
  if (!(files &#x26;&#x26; files.length &#x3e; 0)) {
    cb(&#x27;&#x27;);
  }
  return files.forEach(function(desc) {
    // Work out which template engine to use, based upon the path (TODO split file.sep)
    var engine = selectEngine(desc.file) || defaultEngine;

    var formatter;
    if (engine.selectFormatter) {
      formatter = engine.selectFormatter(desc.file, ss.client.formatters, null);
    }

    var opts = {
      constants: bundler.constants(),
      locals: bundler.locals()
    };

    return bundler.format(desc,
      opts, formatter, function(output) {

      templates.push(wrapTemplate(output, desc.file, ss.bundler.clientFilePath(desc), opts, options, engine, prevEngine));
      prevEngine = engine;

      // Return if last template
      if (templates.length === files.length) {
        output = templates.join(&#x27;&#x27;);
        if (engine !== null &#x26;&#x26; engine.suffix) {
          output += engine.suffix();
        }
        return cb(output);
      }
    }, function(err) {
      ss.log.clientIssue(client,options,err,desc);
      return cb(&#x27;Couldn\&#x27;t format &#x27; + desc.file + err.userInfoHTML);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
module.exports = function(ss, client, options, cb) {
var templateEngine = require(&#x27;./template_engine&#x27;)(ss, options), //TODO why not use the one in client/index ?
    bundler = ss.bundler.get(client);

function templates() {
  var files = bundler.entries(&#x27;tmpl&#x27;),
      output = [];
  templateEngine.<span class="apidocCodeKeywordSpan">generate</span>(bundler, files, function(html) {
    return output.push(html);
  });
  return output;
}

function headers() {
  // Return an array of headers. Order is important!
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.client.templateEngine.load" id="apidoc.element.socketstream.client.templateEngine.load">
        function <span class="apidocSignatureSpan">socketstream.client.templateEngine.</span>load
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">load = function () {
  var templateEngines = {};
  mods.forEach(function(mod) {
    return mod.dirs.forEach(function(dir) {
      templateEngines[dir] = mod.engine;
      return templateEngines[dir];
    });
  });
  return templateEngines;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    ss.defaultTask(&#x27;application&#x27;, function() {});

    ss.defaultTask(&#x27;start-server&#x27;,[&#x27;application&#x27;],function(done) {
socketstream.ws.listen(ss.http.settings.port || 3000, done);
    });

    ss.defaultTask(&#x27;load-api&#x27;, function() {
ss.<span class="apidocCodeKeywordSpan">load</span>();
    });

    ss.defaultTask(&#x27;test-socketstream&#x27;, [&#x27;load-api&#x27;], function() {
var sessionID = ss.session.create();

// jshint loopfunc:true
for (var id in ss.server.responders) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.client.templateEngine.use" id="apidoc.element.socketstream.client.templateEngine.use">
        function <span class="apidocSignatureSpan">socketstream.client.templateEngine.</span>use
        <span class="apidocSignatureSpan">(nameOrModule, dirs, config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">use = function (nameOrModule, dirs, config) {
  if (!dirs) {
    dirs = [&#x27;.&#x27;];
  }
  if (!(dirs instanceof Array)) {
    dirs = [dirs];
  }

  dirs = dirs.map(function(dir) {
    if (dir === &#x27;/&#x27;) {
      return &#x27;.&#x27;;
    }
    if (dir.charAt(0) === &#x27;/&#x27;) {
      return path.join(options.dirs.templates.substring(1), dir.substring(1));
    }
    return path.join(options.dirs.client.substring(1), dir);
  });

  var mod = ss.require(nameOrModule, &#x27;client/template_engines&#x27;, function(err) {
    throw new Error(&#x27;The &#x27; + err.id + &#x27; template engine is not supported by SocketStream internally &#x27;+
      &#x27;or found in the project packages. Please pass a compatible module instead&#x27;);
  });
  var engine;
  if (typeof mod === &#x27;function&#x27;) {
    engine = mod(ss, config, options);
  } else {
    engine = mod.init(ss, config, options);
  }
  return mods.push({
    engine: engine,
    dirs: dirs
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Entry point for gulpfile.js

// Load SocketStream core
var ss = module.exports = require(&#x27;./lib/socketstream.js&#x27;),
    gulp = ss.api.require(&#x27;gulp&#x27;);

// gulp is used as the Orchestrator
ss.tasks.<span class="apidocCodeKeywordSpan">use</span>(gulp);

// Your app.js should be required from the gulpfile.js
// .start() will normally be called from app.js, and will not run tasks.
ss.start = function() {};

// default tasks are defined
ss.tasks.defaults();
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.socketstream.file" id="apidoc.module.socketstream.file">module socketstream.file</a></h1>


    <h2>
        <a href="#apidoc.element.socketstream.file.findExtForBasePath" id="apidoc.element.socketstream.file.findExtForBasePath">
        function <span class="apidocSignatureSpan">socketstream.file.</span>findExtForBasePath
        <span class="apidocSignatureSpan">(basepath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findExtForBasePath = function (basepath) {
    var files = fs.readdirSync(path.join(basepath, &#x27;..&#x27;)),
        basename = path.basename(basepath),
        basenameRegex = new RegExp(&#x27;^&#x27; + basename);

    files = files.filter(function(file) {
        return file.match(basenameRegex) &#x26;&#x26; path.extname(file);
    });
    return files.length ? path.extname(files.sort()[0]) : null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.file.isDir" id="apidoc.element.socketstream.file.isDir">
        function <span class="apidocSignatureSpan">socketstream.file.</span>isDir
        <span class="apidocSignatureSpan">(filePath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isDir = function (filePath) {
    return fs.statSync(filePath).isDirectory();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.file.loadPackageJSON" id="apidoc.element.socketstream.file.loadPackageJSON">
        function <span class="apidocSignatureSpan">socketstream.file.</span>loadPackageJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">loadPackageJSON = function () {
    try {
        return JSON.parse(fs.readFileSync(__dirname + &#x27;/../../package.json&#x27;));
    } catch (e) {
        throw (&#x27;Error: Unable to find or parse SocketStream\&#x27;s package.json file&#x27;);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.file.readDirSync" id="apidoc.element.socketstream.file.readDirSync">
        function <span class="apidocSignatureSpan">socketstream.file.</span>readDirSync
        <span class="apidocSignatureSpan">(start)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readDirSync = function (start) {
    var stat,
        found = {dirs: [], files: [] },
        files,
        abspath,
        x, l;

    try {
<span class="apidocCodeCommentSpan">        /* Use lstat to resolve symlink if we are passed a symlink */
</span>        stat = fs.lstatSync(start)

        /* Read through all the files in this directory */
        if (stat.isDirectory()) {
            files = fs.readdirSync(start).sort();

            for (x = 0, l = files.length; x &#x3c; l; x++) {
                /* replace &#x27;\&#x27; with &#x27;/&#x27; to support Windows */
                abspath = path.join(start, files[x]).replace(/\\/g, &#x27;/&#x27;);

                found = isDir(abspath, found);
            }
        } else {
            throw (new Error(&#x27;path: &#x27; + start + &#x27; is not a directory&#x27;));
        }
        return found;

    } catch (e) {
        /* Ignore if optional dirs are missing */
        if (e.code !== &#x27;ENOENT&#x27;) {
            throw (e);
        }
        return false;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
found = {dirs: [], files: [] }
    }

    if (stat.isDirectory() &#x26;&#x26; !isHidden(abspathAry[abspathAry.length - 1])) {
found.dirs.push(abspath);

/* If we found a directory, recurse! */
data        = exports.<span class="apidocCodeKeywordSpan">readDirSync</span>(abspath);
found.dirs  = found.dirs.concat(data.dirs);
found.files = found.files.concat(data.files);

    } else {

abspathAry = abspath.split(&#x27;/&#x27;);
file_name  = abspathAry[abspathAry.length - 1];
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.socketstream.generate" id="apidoc.module.socketstream.generate">module socketstream.generate</a></h1>


    <h2>
        <a href="#apidoc.element.socketstream.generate.generate" id="apidoc.element.socketstream.generate.generate">
        function <span class="apidocSignatureSpan">socketstream.</span>generate
        <span class="apidocSignatureSpan">(program)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">generate = function (program) {

  var appjs,
      codeExtension = program.coffee &#x26;&#x26; &#x27;coffee&#x27; || &#x27;js&#x27;,
      selectedFormatters = [],
      name               = program.args[1],
      source             = path.join(__dirname, &#x27;../../new_project&#x27;),
      viewExtension      = program.jade &#x26;&#x26; &#x27;jade&#x27; || &#x27;html&#x27;,
      styleExtension     = &#x27;&#x27;,
      mods               = [],
      packagejs          = &#x27;&#x27;,
      clientFiles        = {
        css: [],
        code: []
      },

<span class="apidocCodeCommentSpan">      /**
       * [mkdir description]
       * @param  {String}   dir Directory path to create
       * @return {Boolean}      True if directory successfully created
       */
</span>      mkdir = function(dir) {
        return fs.mkdirSync(path.join(name, dir), dir_mode);
      },

      /**
       * Copy files/directories
       * @param  {[String} src  Copy From directory
       * @param  {[String} dest Copy To directory
       * @return {Object}       Stream object
       */
      cp = function(src, dest) {
        var destination = path.join(name, dest || src),
            read        = fs.createReadStream(path.join(source, src)),
            write       = fs.createWriteStream(destination);

        return read.pipe(write);
      },

      /**
       * Writes content to the file
       * @param  {String} fileName The filepath to write to
       * @param  {[type]} content  Content string
       * @return {Boolean}
       */
      write = function(fileName, content) {
        return fs.writeFileSync(path.join(name, fileName), content, &#x27;utf8&#x27;);
      };

  /* Check for application name existing */
  if (name === void 0) {
    return log(&#x27;Please provide a name for your application: $&#x3e; socketstream new &#x3c;MyAppName&#x3e;&#x27;);
  }

  /* Select stylesheet language */
  if (program.less) {
    styleExtension = &#x27;less&#x27;;
  }
  else if (program.stylus) {
    styleExtension = &#x27;styl&#x27;;
  }
  else {
    styleExtension = &#x27;css&#x27;;
  }

  /* Select formatters for file extensions */
  if (makeRootDirectory(name)) {
    [&#x27;coffee&#x27;, &#x27;jade&#x27;, &#x27;less&#x27;, &#x27;stylus&#x27;].forEach(function(formatter) {
      if (program[formatter]) {
        return selectedFormatters.push(formatter);
      }
    });

    /* Create essential directories */
    mkdir(&#x27;/client&#x27;);
    mkdir(&#x27;/client/code&#x27;);
    mkdir(&#x27;/client/code/app&#x27;);
    mkdir(&#x27;/client/code/libs&#x27;);
    mkdir(&#x27;/client/views&#x27;);
    mkdir(&#x27;/client/css&#x27;);
    mkdir(&#x27;/client/css/libs&#x27;);
    mkdir(&#x27;/client/templates&#x27;);
    mkdir(&#x27;/client/static&#x27;);
    mkdir(&#x27;/client/static/images&#x27;);
    mkdir(&#x27;/server&#x27;);
    mkdir(&#x27;/server/rpc&#x27;);
    mkdir(&#x27;/server/middleware&#x27;);

    /* Copy essential files */
    cp(&#x27;/scm_ignore_file&#x27;, &#x27;/.gitignore&#x27;);
    cp(&#x27;/node_monitor_ignore_file&#x27;, &#x27;/.nodemonignore&#x27;);
    cp(&#x27;/README.md&#x27;);
    cp(&#x27;/client/static/favicon.ico&#x27;);
    cp(&#x27;/client/code/libs/jquery.min.js&#x27;);
    cp(&#x27;/client/code/app/entry.&#x27; + codeExtension);
    clientFiles.code.push(&#x27;../node_modules/es6-shim/es6-shim.js&#x27;);
    clientFiles.code.push(&#x27;libs/jquery.min.js&#x27;);
    clientFiles.code.push(&#x27;app&#x27;);

    /* Install chat demo files */
    if (program.minimal) {
      cp(&#x27;/client/views/app.minimal.&#x27; + viewExtension, &#x27;/client/views/app.&#x27; + viewExtension);
      cp(&#x27;/client/code/app/app.minimal.&#x27; + codeExtension, &#x27;/client/code/app/app.&#x27; + codeExtension);
      cp(&#x27;/client/css/app.minimal.&#x27; + styleExtension, &#x27;/client/css/app.&#x27; + styleExtension);
      cp(&#x27;/server/rpc/.gitkeep&#x27;);
      cp(&#x27;/server/middleware/.gitkeep&#x27;);
      cp(&#x27;/client/templates/.gitkeep&#x27;);
      clientFiles.css.push(&#x27;app.&#x27; + styleExtension);
    } else {
      cp(&#x27;/client/static/images/logo.png&#x27;);
      cp(&#x27;/client/code/app/app.demo.&#x27; + codeExtension, &#x27;/client/code/app/app.&#x27; + codeExtension);
      cp(&#x27;/server/middleware/example.&#x27; + codeExtension);
      cp(&#x27;/server/rpc/demo.&#x27; + codeExtension);
      cp(&#x27;/client/css/app.demo.&#x27; + styleExtension, &#x27;/client/css/app.&#x27; + styleExtension);
      mkdir(&#x27;/client/templates/chat&#x27;);
      cp(&#x27;/client/templates/chat/message.&#x27; + viewExtension);
      cp(&#x27;/client/views/app.demo.&#x27; + viewExtension, &#x27;/client/views/app.&#x27; + viewExtension);
      clientFiles.css.push(&#x27;../node_modules/norm ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
module.exports = function(ss, client, options, cb) {
var templateEngine = require(&#x27;./template_engine&#x27;)(ss, options), //TODO why not use the one in client/index ?
    bundler = ss.bundler.get(client);

function templates() {
  var files = bundler.entries(&#x27;tmpl&#x27;),
      output = [];
  templateEngine.<span class="apidocCodeKeywordSpan">generate</span>(bundler, files, function(html) {
    return output.push(html);
  });
  return output;
}

function headers() {
  // Return an array of headers. Order is important!
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.socketstream.http" id="apidoc.module.socketstream.http">module socketstream.http</a></h1>


    <h2>
        <a href="#apidoc.element.socketstream.http.load" id="apidoc.element.socketstream.http.load">
        function <span class="apidocSignatureSpan">socketstream.http.</span>load
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">load = function () {
  this.cached.loadStatic();
  this.cached.loadAssets();
  debug(&#x27;http: loaded.&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    ss.defaultTask(&#x27;application&#x27;, function() {});

    ss.defaultTask(&#x27;start-server&#x27;,[&#x27;application&#x27;],function(done) {
socketstream.ws.listen(ss.http.settings.port || 3000, done);
    });

    ss.defaultTask(&#x27;load-api&#x27;, function() {
ss.<span class="apidocCodeKeywordSpan">load</span>();
    });

    ss.defaultTask(&#x27;test-socketstream&#x27;, [&#x27;load-api&#x27;], function() {
var sessionID = ss.session.create();

// jshint loopfunc:true
for (var id in ss.server.responders) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.http.route" id="apidoc.element.socketstream.http.route">
        function <span class="apidocSignatureSpan">socketstream.http.</span>route
        <span class="apidocSignatureSpan">(url, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">route = function (url, fn) {
  if (fn &#x26;&#x26; typeof fn === &#x27;function&#x27;) {
    this.cached.route(url, fn);
  } else {
    return {
      serveClient: (function(name) {
        this.cached.route(url,function(req, res) {
          return res.serveClient(name);
        });
      }).bind(this)
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  cp(&#x27;/client/views/app.demo.&#x27; + viewExtension, &#x27;/client/views/app.&#x27; + viewExtension);
  clientFiles.css.push(&#x27;../node_modules/normalize.css/normalize.css&#x27;);
  clientFiles.css.push(&#x27;app.&#x27; + styleExtension);
}

/* Generate app.js */
appjs = &#x27;// My SocketStream 0.4 app\n\nvar ss = require(\&#x27;socketstream\&#x27;);\n\n&#x27;+
        &#x27;// Define a single-page client called \&#x27;main\&#x27;\nss.client.define(\&#x27;main\&#x27;, {\n  view: \&#x27;app
.&#x27; + viewExtension + &#x27;\&#x27;,\n  css:  [\&#x27;&#x27; + (clientFiles.css.join(&#x27;\&#x27;, \&#x27;&#x27;)) + &#x27;\&#x27;],\n  code: [\&#x27;&#x27; + (clientFiles.code.join(&#x27;\&#x27;, \&#x27;&#x27;)) + &#x27;\&#x27;],\n  tmpl: \&#x27;chat\&#x27;\n});\n\n// Serve this client on the root URL\nss.http.<span class="apidocCodeKeywordSpan">route</span>(\&#x27;/\&#x27;, function(req, res){\n  res.serveClient(\&#x27;main\&#x27;);\n});\n&#x27;;

/* List any selected formatters */
if (selectedFormatters.length &#x3e; 0) {
  appjs += &#x27;\n// Code Formatters\n&#x27;;
}
selectedFormatters.forEach(function (name) {
  return appjs += &#x27;ss.client.formatters.add(require(\&#x27;ss-&#x27; + name + &#x27;\&#x27;));\n&#x27;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.http.set" id="apidoc.element.socketstream.http.set">
        function <span class="apidocSignatureSpan">socketstream.http.</span>set
        <span class="apidocSignatureSpan">(newSettings)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">set = function (newSettings) {
  var s = &#x27;&#x27;;

  if (typeof newSettings !== &#x27;object&#x27;) {
    throw new Error(&#x27;ss.http.set() takes an object e.g. {static: {maxAge: 60000}}&#x27;);
  }

  for (s in newSettings) {
    if (newSettings.hasOwnProperty(s)) {
      settings[s] = newSettings[s]
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  app.socketstream = function( fn(req,stream) )

  app.stream = ss.http.stream;
  */
  app.stream = ss.http.stream;

  if (ss.env === &#x27;development&#x27;) {
app.<span class="apidocCodeKeywordSpan">set</span>(&#x27;views&#x27;, ss.client.dirs.views);
// Showing stack errors
app.set(&#x27;showStackError&#x27;, true);
// Disable views cache
app.set(&#x27;view cache&#x27;, false);

// Environment dependent middleware
// throws cannot find stack
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.http.unload" id="apidoc.element.socketstream.http.unload">
        function <span class="apidocSignatureSpan">socketstream.http.</span>unload
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unload = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.socketstream.http.cached" id="apidoc.module.socketstream.http.cached">module socketstream.http.cached</a></h1>


    <h2>
        <a href="#apidoc.element.socketstream.http.cached.loadAssets" id="apidoc.element.socketstream.http.cached.loadAssets">
        function <span class="apidocSignatureSpan">socketstream.http.cached.</span>loadAssets
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">loadAssets = function () {
        var files = glob.sync(&#x27;**/*&#x27;,{cwd:ss.client.dirs.assets,nodir:true})
                      .map(assetPathServed)
                      .filter(function(p) { return p; }),
            prefix = &#x27;/assets/&#x27;; // should this be configurable?

        files.forEach(function(url) {
          route(prefix+url,null,path.join(ss.client.dirs.assets, url));
        });
				debug(&#x27;route ready for assets %s&#x27;, Object.keys(files))
	    }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.http.cached.loadStatic" id="apidoc.element.socketstream.http.cached.loadStatic">
        function <span class="apidocSignatureSpan">socketstream.http.cached.</span>loadStatic
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">loadStatic = function () {
  var assets = path.relative(ss.client.dirs.static,ss.client.dirs.assets);
  var files = glob.sync(&#x27;**/*&#x27;,{cwd:ss.client.dirs.static,nodir:true}).filter(function(p) {
    //TODO exclude directories
    return p.indexOf(assets) !== 0;
  });

  files.forEach(function(url) {
    route(url,null,path.join(ss.client.dirs.static, url));
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.http.cached.middleware" id="apidoc.element.socketstream.http.cached.middleware">
        function <span class="apidocSignatureSpan">socketstream.http.cached.</span>middleware
        <span class="apidocSignatureSpan">(req, res, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function cachedMiddleware(req, res, next) {
		var point = getPoint(req);
		// console.log(&#x27;cmw&#x27;,point,req.url);
		if (point) {
			return point.handle(req,res,next);
		}
		next();
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.http.cached.route" id="apidoc.element.socketstream.http.cached.route">
        function <span class="apidocSignatureSpan">socketstream.http.cached.</span>route
        <span class="apidocSignatureSpan">(url, fn, filePath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function route(url, fn, filePath) {
		if (url.charAt(0) !== &#x27;/&#x27;) { url = &#x27;/&#x27;+url; }
		// console.log(&#x27;route defined&#x27;,url);
		var point = getPoint(url);
		if (point) {
			if (fn) { point.handle = fn; }
			if (filePath) { point.filePath = filePath; }
		} else {
			point = new KnownPoint(url, fn, filePath);
			if (!fn) {
				debug(&#x27;added known point %s pointing to static file %s&#x27;,url,filePath);
			}
		}
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  cp(&#x27;/client/views/app.demo.&#x27; + viewExtension, &#x27;/client/views/app.&#x27; + viewExtension);
  clientFiles.css.push(&#x27;../node_modules/normalize.css/normalize.css&#x27;);
  clientFiles.css.push(&#x27;app.&#x27; + styleExtension);
}

/* Generate app.js */
appjs = &#x27;// My SocketStream 0.4 app\n\nvar ss = require(\&#x27;socketstream\&#x27;);\n\n&#x27;+
        &#x27;// Define a single-page client called \&#x27;main\&#x27;\nss.client.define(\&#x27;main\&#x27;, {\n  view: \&#x27;app
.&#x27; + viewExtension + &#x27;\&#x27;,\n  css:  [\&#x27;&#x27; + (clientFiles.css.join(&#x27;\&#x27;, \&#x27;&#x27;)) + &#x27;\&#x27;],\n  code: [\&#x27;&#x27; + (clientFiles.code.join(&#x27;\&#x27;, \&#x27;&#x27;)) + &#x27;\&#x27;],\n  tmpl: \&#x27;chat\&#x27;\n});\n\n// Serve this client on the root URL\nss.http.<span class="apidocCodeKeywordSpan">route</span>(\&#x27;/\&#x27;, function(req, res){\n  res.serveClient(\&#x27;main\&#x27;);\n});\n&#x27;;

/* List any selected formatters */
if (selectedFormatters.length &#x3e; 0) {
  appjs += &#x27;\n// Code Formatters\n&#x27;;
}
selectedFormatters.forEach(function (name) {
  return appjs += &#x27;ss.client.formatters.add(require(\&#x27;ss-&#x27; + name + &#x27;\&#x27;));\n&#x27;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.http.cached.send" id="apidoc.element.socketstream.http.cached.send">
        function <span class="apidocSignatureSpan">socketstream.http.cached.</span>send
        <span class="apidocSignatureSpan">(url, res)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sendInternal(url, res) {
			if (url.charAt(0) !== &#x27;/&#x27;) { url = &#x27;/&#x27;+url; }
			var point = getPoint(url);
			// console.log(url,res,&#x27;sent&#x27;);
			if (point) {
				point.handle(res.req, res);
			} else {
				ss.log.error(&#x27;Couldn\&#x27;t serve&#x27;, url);
			}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.http.cached.set" id="apidoc.element.socketstream.http.cached.set">
        function <span class="apidocSignatureSpan">socketstream.http.cached.</span>set
        <span class="apidocSignatureSpan">(url, content, mimeType)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function set(url, content, mimeType) {
			if (url.charAt(0) !== &#x27;/&#x27;) { url = &#x27;/&#x27;+url; }
			var point = getPoint(url) || new KnownPoint(url);
			// console.info(&#x27;new url:&#x27;,url, mimeType);
			point.content = content;
			point.mimeType = mimeType;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  app.socketstream = function( fn(req,stream) )

  app.stream = ss.http.stream;
  */
  app.stream = ss.http.stream;

  if (ss.env === &#x27;development&#x27;) {
app.<span class="apidocCodeKeywordSpan">set</span>(&#x27;views&#x27;, ss.client.dirs.views);
// Showing stack errors
app.set(&#x27;showStackError&#x27;, true);
// Disable views cache
app.set(&#x27;view cache&#x27;, false);

// Environment dependent middleware
// throws cannot find stack
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.socketstream.http.session" id="apidoc.module.socketstream.http.session">module socketstream.http.session</a></h1>


    <h2>
        <a href="#apidoc.element.socketstream.http.session.middleware" id="apidoc.element.socketstream.http.session.middleware">
        function <span class="apidocSignatureSpan">socketstream.http.session.</span>middleware
        <span class="apidocSignatureSpan">(req, res, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sessionMiddleware(req, res, next) {
  return ss.session.strategy.sessionMiddleware? ss.session.strategy.sessionMiddleware(req,res,next) : next();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.socketstream.live_reload" id="apidoc.module.socketstream.live_reload">module socketstream.live_reload</a></h1>


    <h2>
        <a href="#apidoc.element.socketstream.live_reload.live_reload" id="apidoc.element.socketstream.live_reload.live_reload">
        function <span class="apidocSignatureSpan">socketstream.</span>live_reload
        <span class="apidocSignatureSpan">(ss, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">live_reload = function (ss, options) {

  var pathlib = require(&#x27;path&#x27;),
      chokidar = ss.require(&#x27;chokidar&#x27;);

  var watchDirs = (function() {
    var _i, _len, _ref, _results;
    _ref = options.liveReload;
    _results = [];
    for (_i = 0, _len = _ref.length; _i &#x3c; _len; _i++) {
      var dir = _ref[_i];
      _results.push(pathlib.join(ss.root, options.dirs[dir] || dir));
    }
    return _results;
  })();

  watcher = chokidar.watch(watchDirs, {
    ignoreInitial: true,
    ignored: /(\/\.|~$)/
  });
  watcher.on(&#x27;add&#x27;, function(path) {
    debug(&#x27;added: %s&#x27;,path);
    return ss.livereload.added(path);
  });
  watcher.on(&#x27;change&#x27;, function(path) {
    debug(&#x27;added: %s&#x27;,path);
    return ss.livereload.changed(path);
  });
  watcher.on(&#x27;unlink&#x27;, function(path) {
    debug(&#x27;added: %s&#x27;,path);
    return ss.livereload.removed(path);
  });
  watcher.on(&#x27;error&#x27;, function(error) {
    return ss.log.error(&#x27;&#x27;.red, (&#x27;Error: &#x27; + error).red);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.live_reload.unload" id="apidoc.element.socketstream.live_reload.unload">
        function <span class="apidocSignatureSpan">socketstream.live_reload.</span>unload
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unload = function () {
  if (watcher) {
    watcher.close();
    watcher = null;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.socketstream.livereload" id="apidoc.module.socketstream.livereload">module socketstream.livereload</a></h1>


    <h2>
        <a href="#apidoc.element.socketstream.livereload.added" id="apidoc.element.socketstream.livereload.added">
        function <span class="apidocSignatureSpan">socketstream.livereload.</span>added
        <span class="apidocSignatureSpan">(changedPath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">added = function (changedPath) {
  return reloadClients(changedPath,&#x27;added&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

watcher = chokidar.watch(watchDirs, {
  ignoreInitial: true,
  ignored: /(\/\.|~$)/
});
watcher.on(&#x27;add&#x27;, function(path) {
  debug(&#x27;added: %s&#x27;,path);
  return ss.livereload.<span class="apidocCodeKeywordSpan">added</span>(path);
});
watcher.on(&#x27;change&#x27;, function(path) {
  debug(&#x27;added: %s&#x27;,path);
  return ss.livereload.changed(path);
});
watcher.on(&#x27;unlink&#x27;, function(path) {
  debug(&#x27;added: %s&#x27;,path);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.livereload.changed" id="apidoc.element.socketstream.livereload.changed">
        function <span class="apidocSignatureSpan">socketstream.livereload.</span>changed
        <span class="apidocSignatureSpan">(changedPath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">changed = function (changedPath) {
  return reloadClients(changedPath,&#x27;changed&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});
watcher.on(&#x27;add&#x27;, function(path) {
  debug(&#x27;added: %s&#x27;,path);
  return ss.livereload.added(path);
});
watcher.on(&#x27;change&#x27;, function(path) {
  debug(&#x27;added: %s&#x27;,path);
  return ss.livereload.<span class="apidocCodeKeywordSpan">changed</span>(path);
});
watcher.on(&#x27;unlink&#x27;, function(path) {
  debug(&#x27;added: %s&#x27;,path);
  return ss.livereload.removed(path);
});
watcher.on(&#x27;error&#x27;, function(error) {
  return ss.log.error(&#x27;&#x27;.red, (&#x27;Error: &#x27; + error).red);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.livereload.removed" id="apidoc.element.socketstream.livereload.removed">
        function <span class="apidocSignatureSpan">socketstream.livereload.</span>removed
        <span class="apidocSignatureSpan">(changedPath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removed = function (changedPath) {
  return reloadClients(changedPath,&#x27;removed&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  });
  watcher.on(&#x27;change&#x27;, function(path) {
    debug(&#x27;added: %s&#x27;,path);
    return ss.livereload.changed(path);
  });
  watcher.on(&#x27;unlink&#x27;, function(path) {
    debug(&#x27;added: %s&#x27;,path);
    return ss.livereload.<span class="apidocCodeKeywordSpan">removed</span>(path);
  });
  watcher.on(&#x27;error&#x27;, function(error) {
    return ss.log.error(&#x27;&#x27;.red, (&#x27;Error: &#x27; + error).red);
  });
};

module.exports.unload = function() {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.socketstream.misc" id="apidoc.module.socketstream.misc">module socketstream.misc</a></h1>


    <h2>
        <a href="#apidoc.element.socketstream.misc.defaults" id="apidoc.element.socketstream.misc.defaults">
        function <span class="apidocSignatureSpan">socketstream.misc.</span>defaults
        <span class="apidocSignatureSpan">(args, defaults)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defaults = function (args, defaults) {
  return exports.extend({}, defaults, args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
ss.tasks.use(gulp);

// Your app.js should be required from the gulpfile.js
// .start() will normally be called from app.js, and will not run tasks.
ss.start = function() {};

// default tasks are defined
ss.tasks.<span class="apidocCodeKeywordSpan">defaults</span>();

// don&#x27;t load API yet as the app.js still needs to be loaded
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.misc.extend" id="apidoc.element.socketstream.misc.extend">
        function <span class="apidocSignatureSpan">socketstream.misc.</span>extend
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extend = function (obj) {
  var source,
      prop,
      i;

  for (i = 1; i &#x3c; arguments.length; i++) {
    source = arguments[i];
    for (prop in source) {
      if (source.hasOwnProperty(prop)) {
        obj[prop] = source[prop];
      }
    }
  }
  return obj;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Useful for declaring default parameter
 *
 * @param  {Object} args      Arguments
 * @param  {Object} defaults  Default arguments
 * @return {Object}           Extended object
 */
exports.defaults = function (args, defaults) {
  return exports.<span class="apidocCodeKeywordSpan">extend</span>({}, defaults, args);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.misc.parseWsMessage" id="apidoc.element.socketstream.misc.parseWsMessage">
        function <span class="apidocSignatureSpan">socketstream.misc.</span>parseWsMessage
        <span class="apidocSignatureSpan">(msg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseWsMessage = function (msg) {
  var i;
  if ((i = msg.indexOf(&#x27;|&#x27;)) &#x3e; 0) {
    return [msg.substr(0, i), msg.substr(i+1)];
  } else {
    throw new Error(&#x27;Invalid message&#x27;);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.misc.randomString" id="apidoc.element.socketstream.misc.randomString">
        function <span class="apidocSignatureSpan">socketstream.misc.</span>randomString
        <span class="apidocSignatureSpan">(len)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">randomString = function (len) {
  var chars = &#x27;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&#x27;.split(&#x27;&#x27;),
      uuid  = [],
      radix = chars.length,
      i;

  for (i = 0; i &#x3c; len; i++) {
    uuid[i] = chars[0 | Math.random()*radix];
  }
  return uuid.join(&#x27;&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.socketstream.publish" id="apidoc.module.socketstream.publish">module socketstream.publish</a></h1>


    <h2>
        <a href="#apidoc.element.socketstream.publish.api" id="apidoc.element.socketstream.publish.api">
        function <span class="apidocSignatureSpan">socketstream.publish.</span>api
        <span class="apidocSignatureSpan">(transport)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">api = function (transport) {
  var methods = {

<span class="apidocCodeCommentSpan">    /**
     * @ngdoc function
     * @name ss.publish#all
     * @methodOf ss.publish:publish
     * @param {string} name Name of the event
     * @param {any} first First parameter (open ended)
     * @description
     * Publish event to all active client browsers
     */
</span>    all: function() {
      var event = arguments[0],
          params = (2 &#x3c;= arguments.length ? __slice.call(arguments, 1) : []),
        obj = {
          t: &#x27;all&#x27;,
          e: event,
          p: params
        };
      transport.send(obj);
      if (!isInternal(event)) {
        return log.info(&#x27;&#x27;.cyan, &#x27;event:all&#x27;.grey, event);
      }
    },
    socketId: function() {
      var socketId = arguments[0],
          event = arguments[1],
          params = (3 &#x3c;= arguments.length ? __slice.call(arguments, 2) : []),
          obj = {
            t: &#x27;socketId&#x27;,
            socketId: socketId,
            e: event,
            p: params
          };
      transport.send(obj);
      return log.info(&#x27;&#x27;.cyan, (&#x27;event:socketId:&#x27; + socketId).grey, event);
    },
    users: function() {
      var users = arguments[0] instanceof Array? arguments[0] : [arguments[0]],
          event = arguments[1],
          params = (3 &#x3c;= arguments.length ? __slice.call(arguments, 2) : []),
          obj = {
            t: &#x27;user&#x27;,
            users: users,
            e: event,
            p: params
          };
      transport.send(obj);
      return log.info(&#x27;&#x27;.cyan, (&#x27;event:users:[&#x27; + (users.join(&#x27;,&#x27;)) + &#x27;]&#x27;).grey, event);
    },

      /**
       * @ngdoc function
       * @name ss.publish#channel
       * @methodOf ss.publish:publish
       * @param {string|array} channel Name of the channel(s)
       * @param {string} event Name of the event
       * @param {any} first First parameter (open ended)
       * @description
       * Publish event to all active client browsers in given channel
       */
    channels: function() {
      var channels = arguments[0] instanceof Array? arguments[0] : [arguments[0]],
          event = arguments[1],
          params = (3 &#x3c;= arguments.length ? __slice.call(arguments, 2) : []),
          obj = {
            t: &#x27;channel&#x27;,
            channels: channels,
            e: event,
            p: params
          };
      transport.send(obj);
      return log.info(&#x27;&#x27;.cyan, (&#x27;event:channels:[&#x27; + (channels.join(&#x27;,&#x27;)) + &#x27;]&#x27;).grey, event);
    }
  };

  // Alias 0.2 command
  methods.broadcast = methods.all;
  // Alias singles to plurals
  methods.channel = methods.channels;
  methods.user = methods.users;

  // Return all methods
  return methods;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.socketstream.publish.transport" id="apidoc.module.socketstream.publish.transport">module socketstream.publish.transport</a></h1>


    <h2>
        <a href="#apidoc.element.socketstream.publish.transport.load" id="apidoc.element.socketstream.publish.transport.load">
        function <span class="apidocSignatureSpan">socketstream.publish.transport.</span>load
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">load = function () {
  if (!transport) {
    this.use(&#x27;internal&#x27;);
  }
  return transport(config); //TODO should this be (ss,config) ?
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    ss.defaultTask(&#x27;application&#x27;, function() {});

    ss.defaultTask(&#x27;start-server&#x27;,[&#x27;application&#x27;],function(done) {
socketstream.ws.listen(ss.http.settings.port || 3000, done);
    });

    ss.defaultTask(&#x27;load-api&#x27;, function() {
ss.<span class="apidocCodeKeywordSpan">load</span>();
    });

    ss.defaultTask(&#x27;test-socketstream&#x27;, [&#x27;load-api&#x27;], function() {
var sessionID = ss.session.create();

// jshint loopfunc:true
for (var id in ss.server.responders) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.publish.transport.use" id="apidoc.element.socketstream.publish.transport.use">
        function <span class="apidocSignatureSpan">socketstream.publish.transport.</span>use
        <span class="apidocSignatureSpan">(nameOrModule, cfg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">use = function (nameOrModule, cfg) {
  var modPath;
  if (!cfg) {
    cfg = {};
  }
  config = cfg;
  transport = (function() {
    if (typeof nameOrModule === &#x27;function&#x27;) {
      return nameOrModule;
    } else {
      modPath = &#x27;./transports/&#x27; + nameOrModule;
      if (require.resolve(modPath)) {
        return require(modPath);
      } else {
        throw new Error(&#x27;Unable to find Publish Event Transport \&#x27;&#x27; + nameOrModule + &#x27;\&#x27; internally. Please pass a module&#x27;);
      }
    }
  })();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Entry point for gulpfile.js

// Load SocketStream core
var ss = module.exports = require(&#x27;./lib/socketstream.js&#x27;),
    gulp = ss.api.require(&#x27;gulp&#x27;);

// gulp is used as the Orchestrator
ss.tasks.<span class="apidocCodeKeywordSpan">use</span>(gulp);

// Your app.js should be required from the gulpfile.js
// .start() will normally be called from app.js, and will not run tasks.
ss.start = function() {};

// default tasks are defined
ss.tasks.defaults();
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.socketstream.responders" id="apidoc.module.socketstream.responders">module socketstream.responders</a></h1>


    <h2>
        <a href="#apidoc.element.socketstream.responders.add" id="apidoc.element.socketstream.responders.add">
        function <span class="apidocSignatureSpan">socketstream.responders.</span>add
        <span class="apidocSignatureSpan">(nameOrModule, config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">add = function (nameOrModule, config) {
  config = config || null;
  var mod = ss.require(nameOrModule, &#x27;request/responders&#x27;,function(err) {
        throw new Error(&#x27;Unable to find the \&#x27;&#x27;+err.id+&#x27;\&#x27; Request Responder internally&#x27;);
      });

  try {
    var id = nameOrModule === &#x27;events&#x27; &#x26;&#x26; &#x27;0&#x27; || ++responderCount;
    //jshint -W093
    return (responders[id] = mod(id, config, ss));
  } catch (e) {
    var responderName = responders[id] &#x26;&#x26; responders[id].name || &#x27;&#x27;,
        err = new Error(&#x27;Unable to initialize Request Responder \&#x27;&#x27; + responderName + &#x27;\&#x27;&#x27;);
    err.stack = e.stack;
    throw e;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        &#x27;// Define a single-page client called \&#x27;main\&#x27;\nss.client.define(\&#x27;main\&#x27;, {\n  view: \&#x27;app
.&#x27; + viewExtension + &#x27;\&#x27;,\n  css:  [\&#x27;&#x27; + (clientFiles.css.join(&#x27;\&#x27;, \&#x27;&#x27;)) + &#x27;\&#x27;],\n  code: [\&#x27;&#x27; + (clientFiles.code.join(&#x27;\&#x27;, \&#x27;&#x27;)) + &#x27;\&#x27;],\n  tmpl: \&#x27;chat\&#x27;\n});\n\n// Serve this client on the root URL\nss.http.route(\&#x27;/\&#x27;, function(req, res){\n  res.serveClient(\&#x27;main\&#x27;);\n});\n&#x27;;

/* List any selected formatters */
if (selectedFormatters.length &#x3e; 0) {
  appjs += &#x27;\n// Code Formatters\n&#x27;;
}
selectedFormatters.forEach(function (name) {
  return appjs += &#x27;ss.client.formatters.<span class="apidocCodeKeywordSpan">add</span>(require(\&#x27;ss-&#x27; + name + &#
x27;\&#x27;));\n&#x27;;
});
appjs += &#x27;\n// Use server-side compiled Hogan (Mustache) templates. Others engines available\n&#x27;+
         &#x27;ss.client.templateEngine.use(require(\&#x27;ss-hogan\&#x27;));\n\n// Minimize and pack assets if you type: SS_ENV
=production node app.js\n&#x27;+
         &#x27;if (ss.env === \&#x27;production\&#x27;) ss.client.packAssets();\n&#x27;;
if (program.repl) {
  appjs += &#x27;\n// Start Console Server (REPL)\n// To install client: sudo npm install -g ss-console\n&#x27;+
           &#x27;// To connect: ss-console &#x3c;optional_host_or_port&#x3e;\nvar consoleServer = require(\&#x27;ss-console\&#x27
;)(ss);\nconsoleServer.listen(5000);\n&#x27;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.responders.clear" id="apidoc.element.socketstream.responders.clear">
        function <span class="apidocSignatureSpan">socketstream.responders.</span>clear
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clear = function () {
  //jshint -W093
  return (useDefaults = false);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.responders.load" id="apidoc.element.socketstream.responders.load">
        function <span class="apidocSignatureSpan">socketstream.responders.</span>load
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">load = function () {
  var middlewareStack = middleware.load();
  if (useDefaults) {
    this.add(&#x27;events&#x27;);
    this.add(&#x27;rpc&#x27;);
  }
  var output = {};
  for (var id in responders) {
    var responder = responders[id];
    output[id] = {
      name: responder.name,
      interfaces: responder.interfaces(middlewareStack)
    };
  }
  return output;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    ss.defaultTask(&#x27;application&#x27;, function() {});

    ss.defaultTask(&#x27;start-server&#x27;,[&#x27;application&#x27;],function(done) {
socketstream.ws.listen(ss.http.settings.port || 3000, done);
    });

    ss.defaultTask(&#x27;load-api&#x27;, function() {
ss.<span class="apidocCodeKeywordSpan">load</span>();
    });

    ss.defaultTask(&#x27;test-socketstream&#x27;, [&#x27;load-api&#x27;], function() {
var sessionID = ss.session.create();

// jshint loopfunc:true
for (var id in ss.server.responders) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.socketstream.session" id="apidoc.module.socketstream.session">module socketstream.session</a></h1>


    <h2>
        <a href="#apidoc.element.socketstream.session.Cookie" id="apidoc.element.socketstream.session.Cookie">
        function <span class="apidocSignatureSpan">socketstream.session.</span>Cookie
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Cookie(options) {
  this.path = &#x27;/&#x27;;
  this.maxAge = null;
  this.httpOnly = true;
  if (options) {merge(this, options);}
  this.originalMaxAge = undefined === this.originalMaxAge ?
      this.maxAge :
      this.originalMaxAge;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.session.MemoryStore" id="apidoc.element.socketstream.session.MemoryStore">
        function <span class="apidocSignatureSpan">socketstream.session.</span>MemoryStore
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MemoryStore() {
  Store.call(this)
  this.sessions = Object.create(null)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.session.Session" id="apidoc.element.socketstream.session.Session">
        function <span class="apidocSignatureSpan">socketstream.session.</span>Session
        <span class="apidocSignatureSpan">(req, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Session(req, data) {
  Object.defineProperty(this, &#x27;req&#x27;, { value: req });
  Object.defineProperty(this, &#x27;id&#x27;, { value: req.sessionID });

  if (typeof data === &#x27;object&#x27; &#x26;&#x26; data !== null) {
    // merge data into this, ignoring prototype properties
    for (var prop in data) {
      if (!(prop in this)) {
        this[prop] = data[prop]
      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.session.Store" id="apidoc.element.socketstream.session.Store">
        function <span class="apidocSignatureSpan">socketstream.session.</span>Store
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Store(){}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.session.create" id="apidoc.element.socketstream.session.create">
        function <span class="apidocSignatureSpan">socketstream.session.</span>create
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create = function () {
  var sessionId = uuid.v1();
  this.strategy.create(sessionId);
  debug(&#x27;created session %s&#x27;,sessionId);
  return sessionId;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    });

    ss.defaultTask(&#x27;load-api&#x27;, function() {
      ss.load();
    });

    ss.defaultTask(&#x27;test-socketstream&#x27;, [&#x27;load-api&#x27;], function() {
      var sessionID = ss.session.<span class="apidocCodeKeywordSpan">create</span>();

      // jshint loopfunc:true
      for (var id in ss.server.responders) {
        if (ss.server.responders.hasOwnProperty(id)) {
var responder = ss.server.responders[id];

if (responder.name &#x26;&#x26; responder.interfaces.internal) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.session.extractSocketSessionToken" id="apidoc.element.socketstream.session.extractSocketSessionToken">
        function <span class="apidocSignatureSpan">socketstream.session.</span>extractSocketSessionToken
        <span class="apidocSignatureSpan">(request)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extractSocketSessionToken = function (request) {
  if (!this.strategy.extractSocketSessionToken) {
    throw new Error(&#x27;No session strategy defined! Did you forget to &#x22;npm install socketstream-cookie-session&#x22; ?&#x27;);
  }
  var id = this.strategy.extractSocketSessionToken(request, this.options);
  debug(&#x27;extracted session id %s&#x27;,id);
  return id;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.session.find" id="apidoc.element.socketstream.session.find">
        function <span class="apidocSignatureSpan">socketstream.session.</span>find
        <span class="apidocSignatureSpan">(sessionId, socketId, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">find = function (sessionId, socketId, cb) {
  return api.store.get().load(sessionId, function(err, session) {
    // Create a new session if we don&#x27;t have this sessionId in memory
    // Note: in production you should be using Redis or another
    // persistent store so this should rarely happen
    if (!session) {
      session = strategy.create(sessionId);
      debug(&#x27;created session for %s&#x27;,sessionId);
    } else {
      debug(&#x27;using existing session for %s&#x27;,sessionId);
    }

    // Append methods to session object
    session.channel = channels(ss, session, socketId);
    session.setUserId = function(userId, cb) {
      if (!cb) {
        cb = function() {};
      }
      if (userId) {
        this.userId = userId;
        this._bindToSocket();
      } else if (this.userId) {  // if null (i.e. user has signed out)
        subscriptions.user.remove(this.userId, socketId);
        delete this.userId;
      }
      return this.save(cb);
    };

    // Bind username and any channel subscriptions to this socketID on each request
    session._bindToSocket = function() {
      if (session.userId) {
        subscriptions.user.add(session.userId, socketId);
      }
      if ((session.channels) &#x26;&#x26; session.channels.length &#x3e; 0) {
        session.channel._bindToSocket();
      }
      return this;
    };
    session.save = function(cb) {
      return sessionStore.set(sessionId, session, cb);
    };
    session._bindToSocket();
    return cb(session);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.session.setStrategy" id="apidoc.element.socketstream.session.setStrategy">
        function <span class="apidocSignatureSpan">socketstream.session.</span>setStrategy
        <span class="apidocSignatureSpan">(_strategy)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setStrategy = function (_strategy) {
  this.strategy = strategy = _strategy;
  debug(&#x27;session strategy defined.&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.socketstream.session.Cookie" id="apidoc.module.socketstream.session.Cookie">module socketstream.session.Cookie</a></h1>


    <h2>
        <a href="#apidoc.element.socketstream.session.Cookie.Cookie" id="apidoc.element.socketstream.session.Cookie.Cookie">
        function <span class="apidocSignatureSpan">socketstream.session.</span>Cookie
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Cookie(options) {
  this.path = &#x27;/&#x27;;
  this.maxAge = null;
  this.httpOnly = true;
  if (options) {merge(this, options);}
  this.originalMaxAge = undefined === this.originalMaxAge ?
      this.maxAge :
      this.originalMaxAge;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.socketstream.session.Cookie.prototype" id="apidoc.module.socketstream.session.Cookie.prototype">module socketstream.session.Cookie.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.socketstream.session.Cookie.prototype.serialize" id="apidoc.element.socketstream.session.Cookie.prototype.serialize">
        function <span class="apidocSignatureSpan">socketstream.session.Cookie.prototype.</span>serialize
        <span class="apidocSignatureSpan">(name, val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">serialize = function (name, val){
  return cookie.serialize(name, val, this.data);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.session.Cookie.prototype.toJSON" id="apidoc.element.socketstream.session.Cookie.prototype.toJSON">
        function <span class="apidocSignatureSpan">socketstream.session.Cookie.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function (){
  return this.data;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.socketstream.session.MemoryStore" id="apidoc.module.socketstream.session.MemoryStore">module socketstream.session.MemoryStore</a></h1>


    <h2>
        <a href="#apidoc.element.socketstream.session.MemoryStore.MemoryStore" id="apidoc.element.socketstream.session.MemoryStore.MemoryStore">
        function <span class="apidocSignatureSpan">socketstream.session.</span>MemoryStore
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MemoryStore() {
  Store.call(this)
  this.sessions = Object.create(null)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.socketstream.session.MemoryStore.prototype" id="apidoc.module.socketstream.session.MemoryStore.prototype">module socketstream.session.MemoryStore.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.socketstream.session.MemoryStore.prototype.all" id="apidoc.element.socketstream.session.MemoryStore.prototype.all">
        function <span class="apidocSignatureSpan">socketstream.session.MemoryStore.prototype.</span>all
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function all(callback) {
  var sessionIds = Object.keys(this.sessions)
  var sessions = Object.create(null)

  for (var i = 0; i &#x3c; sessionIds.length; i++) {
    var sessionId = sessionIds[i]
    var session = getSession(this.sessions, sessionId)

    if (session) {
      sessions[sessionId] = session;
    }
  }

  if (callback) {
     defer(callback, null, sessions);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Emit message to the event responder (always Responder ID 0)
return emitter.emit(&#x27;0&#x27;, obj, {}, andThen());

function andThen() {
  switch (obj.t) {
    case &#x27;all&#x27;:
      return function(msg) {
        return send.<span class="apidocCodeKeywordSpan">all</span>(msg);
      };
    case &#x27;socketId&#x27;:
      return function(msg) {
        return send.socketId(obj.socketId, msg);
      };
    case &#x27;channel&#x27;:
      return function(msg) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.session.MemoryStore.prototype.clear" id="apidoc.element.socketstream.session.MemoryStore.prototype.clear">
        function <span class="apidocSignatureSpan">socketstream.session.MemoryStore.prototype.</span>clear
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function clear(callback) {
  this.sessions = Object.create(null)
  if (callback) {
     defer(callback);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.session.MemoryStore.prototype.destroy" id="apidoc.element.socketstream.session.MemoryStore.prototype.destroy">
        function <span class="apidocSignatureSpan">socketstream.session.MemoryStore.prototype.</span>destroy
        <span class="apidocSignatureSpan">(sessionId, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function destroy(sessionId, callback) {
  delete this.sessions[sessionId]
  if (callback) {
     defer(callback);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.session.MemoryStore.prototype.get" id="apidoc.element.socketstream.session.MemoryStore.prototype.get">
        function <span class="apidocSignatureSpan">socketstream.session.MemoryStore.prototype.</span>get
        <span class="apidocSignatureSpan">(sessionId, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function get(sessionId, callback) {
  defer(callback, null, getSession(this.sessions, sessionId))
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Client Views
// ------------
// Generates HTML output for each single-page view
&#x27;use strict&#x27;;

module.exports = function(ss, client, options, cb) {
var templateEngine = require(&#x27;./template_engine&#x27;)(ss, options), //TODO why not use the one in client/index ?
    bundler = ss.bundler.<span class="apidocCodeKeywordSpan">get</span>(client);

function templates() {
  var files = bundler.entries(&#x27;tmpl&#x27;),
      output = [];
  templateEngine.generate(bundler, files, function(html) {
    return output.push(html);
  });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.session.MemoryStore.prototype.length" id="apidoc.element.socketstream.session.MemoryStore.prototype.length">
        function <span class="apidocSignatureSpan">socketstream.session.MemoryStore.prototype.</span>length
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function length(callback) {
  this.all(function (err, sessions) {
    if (err) { return callback(err); }
    callback(null, Object.keys(sessions).length)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.session.MemoryStore.prototype.set" id="apidoc.element.socketstream.session.MemoryStore.prototype.set">
        function <span class="apidocSignatureSpan">socketstream.session.MemoryStore.prototype.</span>set
        <span class="apidocSignatureSpan">(sessionId, session, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function set(sessionId, session, callback) {
  this.sessions[sessionId] = JSON.stringify(session)
  if (callback) {
     defer(callback);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  app.socketstream = function( fn(req,stream) )

  app.stream = ss.http.stream;
  */
  app.stream = ss.http.stream;

  if (ss.env === &#x27;development&#x27;) {
app.<span class="apidocCodeKeywordSpan">set</span>(&#x27;views&#x27;, ss.client.dirs.views);
// Showing stack errors
app.set(&#x27;showStackError&#x27;, true);
// Disable views cache
app.set(&#x27;view cache&#x27;, false);

// Environment dependent middleware
// throws cannot find stack
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.session.MemoryStore.prototype.touch" id="apidoc.element.socketstream.session.MemoryStore.prototype.touch">
        function <span class="apidocSignatureSpan">socketstream.session.MemoryStore.prototype.</span>touch
        <span class="apidocSignatureSpan">(sessionId, session, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function touch(sessionId, session, callback) {
  var currentSession = getSession(this.sessions, sessionId)

  if (currentSession) {
    // update expiration
    currentSession.cookie = session.cookie
    this.sessions[sessionId] = JSON.stringify(currentSession)
  }

  if (callback) {
     defer(callback);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.socketstream.session.Session" id="apidoc.module.socketstream.session.Session">module socketstream.session.Session</a></h1>


    <h2>
        <a href="#apidoc.element.socketstream.session.Session.Session" id="apidoc.element.socketstream.session.Session.Session">
        function <span class="apidocSignatureSpan">socketstream.session.</span>Session
        <span class="apidocSignatureSpan">(req, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Session(req, data) {
  Object.defineProperty(this, &#x27;req&#x27;, { value: req });
  Object.defineProperty(this, &#x27;id&#x27;, { value: req.sessionID });

  if (typeof data === &#x27;object&#x27; &#x26;&#x26; data !== null) {
    // merge data into this, ignoring prototype properties
    for (var prop in data) {
      if (!(prop in this)) {
        this[prop] = data[prop]
      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.socketstream.session.Session.prototype" id="apidoc.module.socketstream.session.Session.prototype">module socketstream.session.Session.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.socketstream.session.Session.prototype.destroy" id="apidoc.element.socketstream.session.Session.prototype.destroy">
        function <span class="apidocSignatureSpan">socketstream.session.Session.prototype.</span>destroy
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">destroy = function (fn){
  delete this.req.session;
  this.req.sessionStore.destroy(this.id, fn);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.session.Session.prototype.regenerate" id="apidoc.element.socketstream.session.Session.prototype.regenerate">
        function <span class="apidocSignatureSpan">socketstream.session.Session.prototype.</span>regenerate
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">regenerate = function (fn){
  this.req.sessionStore.regenerate(this.req, fn);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.session.Session.prototype.reload" id="apidoc.element.socketstream.session.Session.prototype.reload">
        function <span class="apidocSignatureSpan">socketstream.session.Session.prototype.</span>reload
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reload = function (fn){
  var req = this.req
    , store = this.req.sessionStore;
  store.get(this.id, function(err, sess){
    if (err) {return fn(err);}
    if (!sess) {return fn(new Error(&#x27;failed to load session&#x27;));}
    store.createSession(req, sess);
    fn();
  });
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.session.Session.prototype.resetMaxAge" id="apidoc.element.socketstream.session.Session.prototype.resetMaxAge">
        function <span class="apidocSignatureSpan">socketstream.session.Session.prototype.</span>resetMaxAge
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resetMaxAge = function (){
  this.cookie.maxAge = this.cookie.originalMaxAge;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.session.Session.prototype.save" id="apidoc.element.socketstream.session.Session.prototype.save">
        function <span class="apidocSignatureSpan">socketstream.session.Session.prototype.</span>save
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">save = function (fn){
  this.req.sessionStore.set(this.id, this, fn || function(){});
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  forceArray(names).forEach(function(name) {
    if (session.channels.indexOf(name) === -1) { // clients can only join a channel once
      session.channels.push(name);
      return ss.log.info(&#x27;i&#x27;.green + &#x27; subscribed sessionId &#x27;.grey + session.id + &#x27; to channel &#x27;.grey
 + name);
    }
  });
  this._bindToSocket();
  return session.<span class="apidocCodeKeywordSpan">save</span>(cb);
},

// Unsubscribes the client from one or more channels
unsubscribe: function(names, cb) {
  if (!cb) {
    cb = function() {};
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.session.Session.prototype.touch" id="apidoc.element.socketstream.session.Session.prototype.touch">
        function <span class="apidocSignatureSpan">socketstream.session.Session.prototype.</span>touch
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">touch = function (){
  return this.resetMaxAge();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.socketstream.session.Store" id="apidoc.module.socketstream.session.Store">module socketstream.session.Store</a></h1>


    <h2>
        <a href="#apidoc.element.socketstream.session.Store.Store" id="apidoc.element.socketstream.session.Store.Store">
        function <span class="apidocSignatureSpan">socketstream.session.</span>Store
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Store(){}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.socketstream.session.Store.prototype" id="apidoc.module.socketstream.session.Store.prototype">module socketstream.session.Store.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.socketstream.session.Store.prototype.createSession" id="apidoc.element.socketstream.session.Store.prototype.createSession">
        function <span class="apidocSignatureSpan">socketstream.session.Store.prototype.</span>createSession
        <span class="apidocSignatureSpan">(req, sess)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createSession = function (req, sess){
  var expires = sess.cookie.expires
    , orig = sess.cookie.originalMaxAge;
  sess.cookie = new Cookie(sess.cookie);
  if (&#x27;string&#x27; === typeof expires) { sess.cookie.expires = new Date(expires); }
  sess.cookie.originalMaxAge = orig;
  req.session = new Session(req, sess);
  return req.session;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.session.Store.prototype.load" id="apidoc.element.socketstream.session.Store.prototype.load">
        function <span class="apidocSignatureSpan">socketstream.session.Store.prototype.</span>load
        <span class="apidocSignatureSpan">(sid, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">load = function (sid, fn){
  var self = this;
  this.get(sid, function(err, sess){
    if (err) { debug(&#x27;failed to get %s&#x27;,sid); return fn(err); }
    if (!sess) { debug(&#x27;no session for %s&#x27;,sid); return fn(); }
    var req = { sessionID: sid, sessionStore: self };
    sess = self.createSession(req, sess); // recreate prototypes on persisted data
    fn(null, sess);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    ss.defaultTask(&#x27;application&#x27;, function() {});

    ss.defaultTask(&#x27;start-server&#x27;,[&#x27;application&#x27;],function(done) {
socketstream.ws.listen(ss.http.settings.port || 3000, done);
    });

    ss.defaultTask(&#x27;load-api&#x27;, function() {
ss.<span class="apidocCodeKeywordSpan">load</span>();
    });

    ss.defaultTask(&#x27;test-socketstream&#x27;, [&#x27;load-api&#x27;], function() {
var sessionID = ss.session.create();

// jshint loopfunc:true
for (var id in ss.server.responders) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.session.Store.prototype.regenerate" id="apidoc.element.socketstream.session.Store.prototype.regenerate">
        function <span class="apidocSignatureSpan">socketstream.session.Store.prototype.</span>regenerate
        <span class="apidocSignatureSpan">(req, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">regenerate = function (req, fn){
  var self = this;
  this.destroy(req.sessionID, function(err){
    self.generate(req);
    fn(err);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.socketstream.session.store" id="apidoc.module.socketstream.session.store">module socketstream.session.store</a></h1>


    <h2>
        <a href="#apidoc.element.socketstream.session.store.get" id="apidoc.element.socketstream.session.store.get">
        function <span class="apidocSignatureSpan">socketstream.session.store.</span>get
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get = function () {
  if (sessionStore == null) {
    // notify user that this store is not
    // meant for a production environment
    if (&#x27;production&#x27; === ss.env) {
      ss.log.warn(warning);
    }
    // Define default session store (no default impl for now, is set in session strategy addon socketstream-cookie-session)
    sessionStore = new api.MemoryStore();
    debug(&#x27;Using MemoryStore for ss.session.store&#x27;);
  }
  return sessionStore;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Client Views
// ------------
// Generates HTML output for each single-page view
&#x27;use strict&#x27;;

module.exports = function(ss, client, options, cb) {
var templateEngine = require(&#x27;./template_engine&#x27;)(ss, options), //TODO why not use the one in client/index ?
    bundler = ss.bundler.<span class="apidocCodeKeywordSpan">get</span>(client);

function templates() {
  var files = bundler.entries(&#x27;tmpl&#x27;),
      output = [];
  templateEngine.generate(bundler, files, function(html) {
    return output.push(html);
  });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.session.store.use" id="apidoc.element.socketstream.session.store.use">
        function <span class="apidocSignatureSpan">socketstream.session.store.</span>use
        <span class="apidocSignatureSpan">(nameOrStore, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">use = function (nameOrStore, options) {
  var RedisStore;
  debug(&#x27;Using %s Store for ss.session.store&#x27;,nameOrStore===&#x27;redis&#x27;?&#x27;Redis&#x27;:&#x27;Custom&#x27;);
  // Allow any Connect Session Store *instance* to be used
  //jshint -W093
  return (sessionStore = nameOrStore === &#x27;redis&#x27; ?
    (RedisStore = ss.require(&#x27;connect-redis&#x27;)(api), new RedisStore(options)) :
    nameOrStore);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Entry point for gulpfile.js

// Load SocketStream core
var ss = module.exports = require(&#x27;./lib/socketstream.js&#x27;),
    gulp = ss.api.require(&#x27;gulp&#x27;);

// gulp is used as the Orchestrator
ss.tasks.<span class="apidocCodeKeywordSpan">use</span>(gulp);

// Your app.js should be required from the gulpfile.js
// .start() will normally be called from app.js, and will not run tasks.
ss.start = function() {};

// default tasks are defined
ss.tasks.defaults();
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.socketstream.tasks" id="apidoc.module.socketstream.tasks">module socketstream.tasks</a></h1>


    <h2>
        <a href="#apidoc.element.socketstream.tasks._packTasks" id="apidoc.element.socketstream.tasks._packTasks">
        function <span class="apidocSignatureSpan">socketstream.tasks.</span>_packTasks
        <span class="apidocSignatureSpan">(all)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_packTasks = function (all) {
  var tasks = all? [&#x27;load-api&#x27;]:[&#x27;pack-prepare&#x27;,&#x27;load-api&#x27;];
  ss.bundler.forEach(function(bundler){
    if (all) {
      tasks.push(bundler.client.name + &#x27;:pack&#x27;);
    } else if (bundler.packNeeded) {
      tasks.push(bundler.client.name + &#x27;:pack-needed&#x27;);
      tasks.push(bundler.client.name + &#x27;:pack&#x27;);
    } else {
      tasks.push(bundler.client.name + &#x27;:pack-unneeded&#x27;);
    }
  });
  return tasks;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      ss.defaultTask(name+&#x27;:pack&#x27;, [
        name+&#x27;:pack-prepare&#x27;,
        name+&#x27;:pack-css&#x27;,
        name+&#x27;:pack-js&#x27;,
        name+&#x27;:pack-html&#x27;]);
    });

    ss.defaultTask(&#x27;pack-all&#x27;, this.<span class="apidocCodeKeywordSpan">_packTasks</span>(true));
    ss.defaultTask(&#x27;pack-if-needed&#x27;, this._packTasks());
    ss.defaultTask(&#x27;pack-prepare&#x27;, function() {
      log.info(&#x27;i&#x27;.green, &#x27;Attempting to find pre-packed assets... (force repack with SS_PACK=1)&#x27;.grey);
    });
  };
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.tasks.add" id="apidoc.element.socketstream.tasks.add">
        function <span class="apidocSignatureSpan">socketstream.tasks.</span>add
        <span class="apidocSignatureSpan">(name, dependents, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function task(name, dependents, fn) {
  orchestrator.add(name, dependents, fn);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        &#x27;// Define a single-page client called \&#x27;main\&#x27;\nss.client.define(\&#x27;main\&#x27;, {\n  view: \&#x27;app
.&#x27; + viewExtension + &#x27;\&#x27;,\n  css:  [\&#x27;&#x27; + (clientFiles.css.join(&#x27;\&#x27;, \&#x27;&#x27;)) + &#x27;\&#x27;],\n  code: [\&#x27;&#x27; + (clientFiles.code.join(&#x27;\&#x27;, \&#x27;&#x27;)) + &#x27;\&#x27;],\n  tmpl: \&#x27;chat\&#x27;\n});\n\n// Serve this client on the root URL\nss.http.route(\&#x27;/\&#x27;, function(req, res){\n  res.serveClient(\&#x27;main\&#x27;);\n});\n&#x27;;

/* List any selected formatters */
if (selectedFormatters.length &#x3e; 0) {
  appjs += &#x27;\n// Code Formatters\n&#x27;;
}
selectedFormatters.forEach(function (name) {
  return appjs += &#x27;ss.client.formatters.<span class="apidocCodeKeywordSpan">add</span>(require(\&#x27;ss-&#x27; + name + &#
x27;\&#x27;));\n&#x27;;
});
appjs += &#x27;\n// Use server-side compiled Hogan (Mustache) templates. Others engines available\n&#x27;+
         &#x27;ss.client.templateEngine.use(require(\&#x27;ss-hogan\&#x27;));\n\n// Minimize and pack assets if you type: SS_ENV
=production node app.js\n&#x27;+
         &#x27;if (ss.env === \&#x27;production\&#x27;) ss.client.packAssets();\n&#x27;;
if (program.repl) {
  appjs += &#x27;\n// Start Console Server (REPL)\n// To install client: sudo npm install -g ss-console\n&#x27;+
           &#x27;// To connect: ss-console &#x3c;optional_host_or_port&#x3e;\nvar consoleServer = require(\&#x27;ss-console\&#x27
;)(ss);\nconsoleServer.listen(5000);\n&#x27;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.tasks.defaultTask" id="apidoc.element.socketstream.tasks.defaultTask">
        function <span class="apidocSignatureSpan">socketstream.tasks.</span>defaultTask
        <span class="apidocSignatureSpan">(name, dependents, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function defaultTask(name, dependents, fn) {
  if (!orchestrator.hasTask(name)) {
    orchestrator.add(name, dependents, fn);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
log = require(&#x27;../utils/log&#x27;),
view = require(&#x27;../client/view&#x27;),
liveReload = require(&#x27;./live_reload&#x27;);

module.exports = function(ss, options, orchestrator) {

  return function() {
ss.<span class="apidocCodeKeywordSpan">defaultTask</span>(&#x27;application&#x27;, function() {});

ss.defaultTask(&#x27;start-server&#x27;,[&#x27;application&#x27;],function(done) {
  socketstream.ws.listen(ss.http.settings.port || 3000, done);
});

ss.defaultTask(&#x27;load-api&#x27;, function() {
  ss.load();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.tasks.defaults" id="apidoc.element.socketstream.tasks.defaults">
        function <span class="apidocSignatureSpan">socketstream.tasks.</span>defaults
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defaults = function () {
  ss.defaultTask(&#x27;application&#x27;, function() {});

  ss.defaultTask(&#x27;start-server&#x27;,[&#x27;application&#x27;],function(done) {
    socketstream.ws.listen(ss.http.settings.port || 3000, done);
  });

  ss.defaultTask(&#x27;load-api&#x27;, function() {
    ss.load();
  });

  ss.defaultTask(&#x27;test-socketstream&#x27;, [&#x27;load-api&#x27;], function() {
    var sessionID = ss.session.create();

    // jshint loopfunc:true
    for (var id in ss.server.responders) {
      if (ss.server.responders.hasOwnProperty(id)) {
        var responder = ss.server.responders[id];

        if (responder.name &#x26;&#x26; responder.interfaces.internal) {
          var fn = function(){
            var args = Array.prototype.slice.call(arguments),
                cb = args.pop();

            return responder.interfaces.internal(args, {sessionId: sessionID, transport: &#x27;test&#x27;}, function(err, params){ cb(params
); });
          };
          ss.add(responder.name, fn); // interesting, potential or hack?
        }
      }
    }
  });

  // task: ondemand
  // Listen out for requests to async load new assets
  ss.defaultTask(&#x27;serve&#x27;, function serveOndemand(done) {
    ss.bundler.updateCachedOndemandAssets(); //TODO pipe to cache

    socketstream.ws.listen(ss.http.settings.port || 3000);

    // Send server instance to any registered modules (e.g. console)
    ss.events.emit(&#x27;server:start&#x27;, ss.server);

    process.on(&#x27;exit&#x27;, function() {
      if (done) {
        done();
      }
      ss.events.emit(&#x27;server:stop&#x27;, ss.server);
      if (orchestrator.hasTask(&#x27;stop-server&#x27;)) {
          orchestrator.start(&#x27;stop-server&#x27;,function() {
            ss.server = null;
          });
      }
    });
  });

  ss.defaultTask(&#x27;live-assets&#x27;, function() {
    ss.load();
    //TODO ss.started promise to wait for. resolved when streaming server is started
    ss.bundler.forEach(function(bundler) {
      bundler.updateCachedDevAssets();
    });
  });

  ss.defaultTask(&#x27;live-reload&#x27;, function() {
    liveReload(ss, options);
  });

  ss.defaultTask(&#x27;stop-server&#x27;, function() {
    if (ss.server.httServer) {
      ss.server.httServer.close(); //TODO do it on ss.ws
      debug(&#x27;stopped http server.&#x27;);
    }
  });

  var defaultDeps = [];

  if (options.packedAssets) {
    defaultDeps.push(options.packedAssets.all? &#x27;pack-all&#x27;:&#x27;pack-if-needed&#x27;);
  } else if (!options.servePacked) {
    defaultDeps.push(&#x27;live-assets&#x27;);
  }
  if (options.liveReload) {
    defaultDeps.push(&#x27;live-reload&#x27;);
  }
  // if (httpServer)
  defaultDeps.push(&#x27;serve&#x27;);

  ss.defaultTask(&#x27;default&#x27;,defaultDeps);

  ss.bundler.forEach(function(bundler) {
    var name = bundler.client.name;
    ss.defaultTask(name+&#x27;:pack-unneeded&#x27;, function() {
      log.info(&#x27;&#x27;.green, (&#x27;Serving client \&#x27;&#x27; + name + &#x27;\&#x27; using pre-packed assets (ID &#x27; +
          bundler.client.id + &#x27;)&#x27;).grey);
    });
    ss.defaultTask(name+&#x27;:pack-needed&#x27;, function() {
      log.info(&#x27;!&#x27;.red, (&#x27;Unable to find pre-packed assets for \&#x27;&#x27; +
          name + &#x27;\&#x27;. All assets will be repacked&#x27;).grey);
    });
    ss.defaultTask(name+&#x27;:pack-prepare&#x27;, function(done) {
      bundler.client.pack = true;
      log.info((&#x27;Pre-packing and minifying the \&#x27;&#x27; + name + &#x27;\&#x27; client...&#x27;).yellow);

      //Prepare folder
      mkdir(bundler.dests.containerDir); //TODO async
      mkdir(bundler.dests.dir);
      if (!(options.packedAssets &#x26;&#x26; options.packedAssets.keepOldFiles)) {
        deleteOldFiles(bundler.dests.dir);
      }
      done();

      //TODO add the tasks to an async queue that can be asserted on in tests
    });

    ss.defaultTask(bundler.client.name+&#x27;:pack-css&#x27;, function(done) {
      ss.bundler.packAssetSet(&#x27;css&#x27;, bundler.client, bundler.toMinifiedCSS,done);
    });

    ss.defaultTask(bundler.client.name+&#x27;:pack-js&#x27;, function(done) {
      //TODO wait for ss.loaded promise to have socketstream-transport defined
      ss.bundler.packAssetSet(&#x27;js&#x27;, bundler.client, bundler.toMinifiedJS,done);
    });

    ss.defaultTask(bundler.client.name+&#x27;:pack-html&#x27;, function(done) {
      view(ss, bundler.client, options, function(html) {
        fs.writeFileSync(bundler.dests.paths.html, ht ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
ss.tasks.use(gulp);

// Your app.js should be required from the gulpfile.js
// .start() will normally be called from app.js, and will not run tasks.
ss.start = function() {};

// default tasks are defined
ss.tasks.<span class="apidocCodeKeywordSpan">defaults</span>();

// don&#x27;t load API yet as the app.js still needs to be loaded
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.tasks.forget" id="apidoc.element.socketstream.tasks.forget">
        function <span class="apidocSignatureSpan">socketstream.tasks.</span>forget
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forget = function () {
  for(var n in orchestrator.tasks) {
    delete orchestrator.tasks[n];
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.tasks.on" id="apidoc.element.socketstream.tasks.on">
        function <span class="apidocSignatureSpan">socketstream.tasks.</span>on
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">on = function () {
  orchestrator.on.apply(orchestrator,arguments);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		}

		if (this.filePath) {
			var stream = send(req, this.filePath, this.options);

			if (next) {
				// forward non-404 errors
				stream.<span class="apidocCodeKeywordSpan">on</span>(&#x27;error&#x27;, function error(err) {
					next(err.status === 404? null : err);
				});
			}

			stream.pipe(res);
			return;
		}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.tasks.plan" id="apidoc.element.socketstream.tasks.plan">
        function <span class="apidocSignatureSpan">socketstream.tasks.</span>plan
        <span class="apidocSignatureSpan">(args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">plan = function (args) {
  var plan = {}, httpServer = args[0];
  plan.targets = Array.prototype.slice.call(args);
  if (args.length === 0 || typeof httpServer === &#x27;string&#x27; || httpServer instanceof Array) {
    plan.httpServer = null;
  } else {
    plan.httpServer = httpServer;
    plan.targets.shift();
  }
  var last = plan.targets[plan.targets.length-1];
  if (typeof last === &#x27;function&#x27;) {
    plan.callback = last;
    plan.targets.pop();
  }
  if (plan.targets[0] instanceof Array) {
    plan.targets = plan.targets[0];
  }
  if (plan.targets.length === 0) {
    plan.targets.push(&#x27;default&#x27;);
  }

  return plan;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.tasks.start" id="apidoc.element.socketstream.tasks.start">
        function <span class="apidocSignatureSpan">socketstream.tasks.</span>start
        <span class="apidocSignatureSpan">(tasks, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">start = function (tasks, done) {
  orchestrator.start(tasks, doneIfAllDone);
  return this;

  function doneIfAllDone(err) {
    if (err) {
      log.error(&#x27;!&#x27;.red, &#x27;task failed&#x27;, err);
    }

    if (!orchestrator.isRunning &#x26;&#x26; done) {
      done(err);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var ss = module.exports = require(&#x27;./lib/socketstream.js&#x27;),
    gulp = ss.api.require(&#x27;gulp&#x27;);

// gulp is used as the Orchestrator
ss.tasks.use(gulp);

// Your app.js should be required from the gulpfile.js
// .<span class="apidocCodeKeywordSpan">start</span>() will normally be called from app.js, and will not run tasks.
ss.start = function() {};

// default tasks are defined
ss.tasks.defaults();

// don&#x27;t load API yet as the app.js still needs to be loaded
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.tasks.unload" id="apidoc.element.socketstream.tasks.unload">
        function <span class="apidocSignatureSpan">socketstream.tasks.</span>unload
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unload = function () {
  liveReload.unload();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.tasks.use" id="apidoc.element.socketstream.tasks.use">
        function <span class="apidocSignatureSpan">socketstream.tasks.</span>use
        <span class="apidocSignatureSpan">(gulp)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">use = function (gulp) {
  orchestrator = this.orchestrator = gulp;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Entry point for gulpfile.js

// Load SocketStream core
var ss = module.exports = require(&#x27;./lib/socketstream.js&#x27;),
    gulp = ss.api.require(&#x27;gulp&#x27;);

// gulp is used as the Orchestrator
ss.tasks.<span class="apidocCodeKeywordSpan">use</span>(gulp);

// Your app.js should be required from the gulpfile.js
// .start() will normally be called from app.js, and will not run tasks.
ss.start = function() {};

// default tasks are defined
ss.tasks.defaults();
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.socketstream.tasks.orchestrator" id="apidoc.module.socketstream.tasks.orchestrator">module socketstream.tasks.orchestrator</a></h1>


    <h2>
        <a href="#apidoc.element.socketstream.tasks.orchestrator.set" id="apidoc.element.socketstream.tasks.orchestrator.set">
        function <span class="apidocSignatureSpan">socketstream.tasks.orchestrator.</span>set
        <span class="apidocSignatureSpan">(where, what)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">set = function (where, what) {
  var path = require(&#x27;path&#x27;);

  if (where === &#x27;*&#x27;) {
    if (what.root) {
      if (path.isAbsolute(what.root)) {
        exports.root = api.root = what.root;
      } else {
        var scriptBase = path.dirname(process.argv[1]);
        exports.root = api.root = path.join(scriptBase,what.root);
      }
    }

    if (what.client) {
      client.set(what.client);
    }
    if (what.http) {
      http.set(what.http);
    }
    //TODO vars, locals remembered as fallbacks
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  app.socketstream = function( fn(req,stream) )

  app.stream = ss.http.stream;
  */
  app.stream = ss.http.stream;

  if (ss.env === &#x27;development&#x27;) {
app.<span class="apidocCodeKeywordSpan">set</span>(&#x27;views&#x27;, ss.client.dirs.views);
// Showing stack errors
app.set(&#x27;showStackError&#x27;, true);
// Disable views cache
app.set(&#x27;view cache&#x27;, false);

// Environment dependent middleware
// throws cannot find stack
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.tasks.orchestrator.start" id="apidoc.element.socketstream.tasks.orchestrator.start">
        function <span class="apidocSignatureSpan">socketstream.tasks.orchestrator.</span>start
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">start = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var ss = module.exports = require(&#x27;./lib/socketstream.js&#x27;),
    gulp = ss.api.require(&#x27;gulp&#x27;);

// gulp is used as the Orchestrator
ss.tasks.use(gulp);

// Your app.js should be required from the gulpfile.js
// .<span class="apidocCodeKeywordSpan">start</span>() will normally be called from app.js, and will not run tasks.
ss.start = function() {};

// default tasks are defined
ss.tasks.defaults();

// don&#x27;t load API yet as the app.js still needs to be loaded
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.tasks.orchestrator.task" id="apidoc.element.socketstream.tasks.orchestrator.task">
        function <span class="apidocSignatureSpan">socketstream.tasks.orchestrator.</span>task
        <span class="apidocSignatureSpan">(name, dependents, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function task(name, dependents, fn) {
  orchestrator.add(name, dependents, fn);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




























</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.socketstream.unique_set" id="apidoc.module.socketstream.unique_set">module socketstream.unique_set</a></h1>


    <h2>
        <a href="#apidoc.element.socketstream.unique_set.UniqueSet" id="apidoc.element.socketstream.unique_set.UniqueSet">
        function <span class="apidocSignatureSpan">socketstream.unique_set.</span>UniqueSet
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function UniqueSet() {
  this.data = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.socketstream.ws" id="apidoc.module.socketstream.ws">module socketstream.ws</a></h1>


    <h2>
        <a href="#apidoc.element.socketstream.ws.listen" id="apidoc.element.socketstream.ws.listen">
        function <span class="apidocSignatureSpan">socketstream.ws.</span>listen
        <span class="apidocSignatureSpan">(port, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listen = function (port, cb) {
  ss.load();
  ss.log.info(&#x27;Starting SocketStream %s in %s mode...&#x27;.green, ss.version, ss.env);
  if (Number(ss.version.split(&#x27;.&#x27;)[1]) % 2) {
    ss.log.info(&#x27;This is an unstable version, some features will not be reliable&#x27;.yellow);
  }
  return transport.http.listen(port,function() {
    debug(&#x27;started streaming server.&#x27;);
    if (cb) {
      return cb();
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return appjs += &#x27;ss.client.formatters.add(require(\&#x27;ss-&#x27; + name + &#x27;\&#x27;));\n&#x27;;
});
appjs += &#x27;\n// Use server-side compiled Hogan (Mustache) templates. Others engines available\n&#x27;+
         &#x27;ss.client.templateEngine.use(require(\&#x27;ss-hogan\&#x27;));\n\n// Minimize and pack assets if you type: SS_ENV
=production node app.js\n&#x27;+
         &#x27;if (ss.env === \&#x27;production\&#x27;) ss.client.packAssets();\n&#x27;;
if (program.repl) {
  appjs += &#x27;\n// Start Console Server (REPL)\n// To install client: sudo npm install -g ss-console\n&#x27;+
           &#x27;// To connect: ss-console &#x3c;optional_host_or_port&#x3e;\nvar consoleServer = require(\&#x27;ss-console\&#x27
;)(ss);\nconsoleServer.<span class="apidocCodeKeywordSpan">listen</span>(5000);\n&#x27;;
}
appjs += &#x27;\n// Start SocketStream\nss.start();&#x27;;
write(&#x27;/app.js&#x27;, appjs);

/* Generate package.json */
packagejs = &#x27;{\n  &#x22;name&#x22;: &#x22;&#x27; + name + &#x27;&#x22;,\n  &#x22;description&#x22;: &#x22;An awesome real time
 application&#x22;,\n  &#x22;version&#x22;: &#x22;0.0.1&#x22;,\n&#x27;+
            &#x27;  &#x22;author&#x22;: &#x22;Me &#x3c;me@mydomain.com&#x3e;&#x22;,\n  &#x22;private&#x22;: true,\n  &#x22;engines
&#x22;: { &#x22;node&#x22;: &#x22;&#x3e;= 0.10.0&#x22; },\n  &#x22;dependencies&#x22;: {&#x27;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.ws.load" id="apidoc.element.socketstream.ws.load">
        function <span class="apidocSignatureSpan">socketstream.ws.</span>load
        <span class="apidocSignatureSpan">(responders, eventTransport)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">load = function (responders, eventTransport) {
  var thisTransport = transport.load();

  // Dispatch incoming events to websocket clients
  require(&#x27;./event_dispatcher&#x27;)(eventTransport, thisTransport, emitter);

  // Listen to incoming requests and invoke server.request
  for (var id in responders) {
    var responder = responders[id];
    emitter.on(id, responder.interfaces.websocket);
  }

  // Return active WS transport
  return thisTransport;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    ss.defaultTask(&#x27;application&#x27;, function() {});

    ss.defaultTask(&#x27;start-server&#x27;,[&#x27;application&#x27;],function(done) {
socketstream.ws.listen(ss.http.settings.port || 3000, done);
    });

    ss.defaultTask(&#x27;load-api&#x27;, function() {
ss.<span class="apidocCodeKeywordSpan">load</span>();
    });

    ss.defaultTask(&#x27;test-socketstream&#x27;, [&#x27;load-api&#x27;], function() {
var sessionID = ss.session.create();

// jshint loopfunc:true
for (var id in ss.server.responders) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.ws.unload" id="apidoc.element.socketstream.ws.unload">
        function <span class="apidocSignatureSpan">socketstream.ws.</span>unload
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unload = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.socketstream.ws.transport" id="apidoc.module.socketstream.ws.transport">module socketstream.ws.transport</a></h1>


    <h2>
        <a href="#apidoc.element.socketstream.ws.transport.load" id="apidoc.element.socketstream.ws.transport.load">
        function <span class="apidocSignatureSpan">socketstream.ws.transport.</span>load
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">load = function () {
  //TODO error handle missing require from within the sockjs/engineio module
  var transport = ss.require(mid, &#x27;websocket/transports&#x27;, &#x27;engineio&#x27;);
  if (typeof transport !== &#x27;function&#x27;) {
    ss.log.error(&#x27;Transport for &#x22;&#x27;+mid+&#x27;&#x22; must be a function(ss, emitter, config) default:&#x27;, transport);
  } else {
    return (active = transport(ss, emitter, config));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    ss.defaultTask(&#x27;application&#x27;, function() {});

    ss.defaultTask(&#x27;start-server&#x27;,[&#x27;application&#x27;],function(done) {
socketstream.ws.listen(ss.http.settings.port || 3000, done);
    });

    ss.defaultTask(&#x27;load-api&#x27;, function() {
ss.<span class="apidocCodeKeywordSpan">load</span>();
    });

    ss.defaultTask(&#x27;test-socketstream&#x27;, [&#x27;load-api&#x27;], function() {
var sessionID = ss.session.create();

// jshint loopfunc:true
for (var id in ss.server.responders) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.socketstream.ws.transport.use" id="apidoc.element.socketstream.ws.transport.use">
        function <span class="apidocSignatureSpan">socketstream.ws.transport.</span>use
        <span class="apidocSignatureSpan">(nameOrModule, cfg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">use = function (nameOrModule, cfg) {
  mid = nameOrModule;
  config = cfg || config;

  // log warning
  // if (ss.require.resolve(nameOrModule, &#x27;websocket/transports&#x27;) == null) {
  //   throw new Error(&#x27;Unable to find the \&#x27;&#x27; + nameOrModule + &#x27;\&#x27; websocket transport internally&#x27;);
  // }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Entry point for gulpfile.js

// Load SocketStream core
var ss = module.exports = require(&#x27;./lib/socketstream.js&#x27;),
    gulp = ss.api.require(&#x27;gulp&#x27;);

// gulp is used as the Orchestrator
ss.tasks.<span class="apidocCodeKeywordSpan">use</span>(gulp);

// Your app.js should be required from the gulpfile.js
// .start() will normally be called from app.js, and will not run tasks.
ss.start = function() {};

// default tasks are defined
ss.tasks.defaults();
...</pre></li>
    </ul>






</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
